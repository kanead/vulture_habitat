# try the amt package
trk <-
mk_track(
morgan_data,
.x = long,
.y = lat,
.t = time,
id = id,
species = species,
crs = CRS("+init=epsg:4326")
)
#' Save the class here (and apply it later after adding columns to the
#' object)
trk.class<-class(trk)
# nest by id
nesttrk<-trk%>%nest(-id)
nesttrk
#' ## SSF prep
#'
#' SSFs assume that data have been collected at regular time intervals.
#' We can use the track_resample function to regularize the trajectory so that
#' all points are located within some tolerence of each other in time. To figure
#' out a meaningful tolerance range, we should calculate time differences between
#' locations & look at as a function of individual.
(timestats<-trk %>% nest(-id) %>% mutate(sr = map(data, summarize_sampling_rate)) %>%
dplyr::select(id, sr) %>% unnest)
#' add species names to the time intervals
timestats <- timestats %>%
left_join(trk %>%
distinct(id, species), by = 'id')
#' add the study name
timestats$study <- "morgan"
head(timestats)
#' make sure it matches up
filter(trk,id=="X027") # cv
filter(trk,id=="X016_Complete") # cv
#' Time intervals range from every 2 to 15 minutes on average, depending
#' on the individual.  Lets add on the time difference to each obs.
trk<-trk %>% group_by(id) %>% mutate(dt_ = t_ - lag(t_, default = NA))
trk
# let's select just the CVs
trk <- filter(trk,species=="cv")
trk
900/60
levels(trk$id)
levels(as.factor(trk$id))
# need to run timestats again for the subsetted dataframe so that the IDs match up below
(timestats<-trk %>% nest(-id) %>% mutate(sr = map(data, summarize_sampling_rate)) %>%
dplyr::select(id, sr) %>% unnest)
# select individuals that have temporal resolution of ~ 15 mins
trk<- filter(trk,id=="X027"|
id=="X042"|
id=="X023"|
id=="X050"|
id=="X051"|
id=="X053"|
id=="X052"|
id=="X071"|
id=="X056"|
id=="X057"|
id=="X055")
# need to run timestats again for the subsetted dataframe so that the IDs match up below
(timestats<-trk %>% nest(-id) %>% mutate(sr = map(data, summarize_sampling_rate)) %>%
dplyr::select(id, sr) %>% unnest)
?track_resample
#+warning=FALSE
ssfdat<-NULL
temptrk<-with(trk, track(x=x_, y=y_, t=t_, id=id))
uid<-unique(trk$id) # individual identifiers
luid<-length(uid) # number of unique individuals
for(i in 1:luid){
# Subset individuals & regularize track
temp<-temptrk%>% filter(id==uid[i]) %>%
track_resample(rate=hours(1),
tolerance=minutes(10))
# Get rid of any bursts without at least 2 points
temp<-filter_min_n_burst(temp, 2)
# burst steps
stepstemp<-steps_by_burst(temp)
# create random steps using fitted gamma and von mises distributions and append
rnd_stps <- stepstemp %>%  random_steps(n = 15)
# append id
rnd_stps<-rnd_stps%>%mutate(id=uid[i])
# append new data to data from other individuals
ssfdat<-rbind(rnd_stps, ssfdat)
}
ssfdat<-as_tibble(ssfdat)
ssfdat
#' convert our regularised data back into a trk type data frame
home_range_data <- ssfdat %>% filter(case_=="TRUE") %>% select(x1_, y1_, t1_, id) %>% group_by(id)
#' convert our regularised data back into a trk type data frame
home_range_data <-
ssfdat %>% filter(case_ == "TRUE") %>% select(x1_, y1_, t1_, id) %>% group_by(id)
home_range_trk <-
mk_track(
home_range_data,
.x = x1_,
.y = y1_,
.t = t1_,
id = id,
crs = CRS("+init=epsg:4326")
)
mcps <-home_range_trk %>% nest(-id) %>%
mutate(mcparea = map(data, ~hr_mcp(., levels = c(0.95)) %>% hr_area)) %>%
select(id, mcparea) %>% unnest()
#+fig.height=12, fig.width=12, warning=FALSE, message=FALSE
ggplot(mcps, aes(x = id, y = area)) + geom_point()+
geom_smooth()
#' Same for KDE
kde <-home_range_trk %>% nest(-id) %>%
mutate(kdearea = map(data, ~hr_kde(., levels=c(0.95)) %>% hr_area)) %>%
select(id, kdearea) %>% unnest()
#+fig.height=12, fig.width=12, warning=FALSE, message=FALSE
ggplot(kde, aes(x = id, y = kdearea)) + geom_point()+
geom_smooth()
#' map the data
library(leaflet)
levels(as.factor(home_range_data$id))
leaflet() %>% addTiles() %>%
addCircleMarkers(data = filter(home_range_data, id == "X055"),
lat = ~y1_, lng = ~x1_,
color = "blue")
levels(as.factor(home_range_data$id))
leaflet() %>% addTiles() %>%
addCircleMarkers(data = filter(home_range_data, id == "X057"),
lat = ~y1_, lng = ~x1_,
color = "blue")
#' map the data
library(leaflet)
levels(as.factor(home_range_data$id))
leaflet() %>% addTiles() %>%
addCircleMarkers(data = filter(home_range_data, id == "X071"),
lat = ~y1_, lng = ~x1_,
color = "blue")
home_range_data
home_range_data
trk
filter(trk, id == "X055")
?track_resample
filter(trk, id == "X055")
filter(trk, id == "X071")
840/60
filter(home_range_data, id == "X071")
levels(as.factor(home_range_data$id))
filter(home_range_data, id == "X023")
library(lubridate)
library(SDLfilter)
library(amt)
library(sp)
# select swazi data which is the data we tracked in Swaziland
swazi_data <- filter(mydata, study == "swazi")
swazi_data
#' Check for duplicated observations (ones with same lat, long, timestamp,
#'  and individual identifier).
ind2<-swazi_data %>% select(time, long, lat, id) %>%
duplicated
sum(ind2)
# remove them
swazi_data$dups <- ind2
swazi_data <- filter(swazi_data,dups=="FALSE")
swazi_data
# set the time column
levels(factor(swazi_data$id))
# can look at an individual level with
(filter(swazi_data,id=="ID1"))
# all of the data is in the format of day-month-year
swazi_data$New_time<-parse_date_time(x=swazi_data$time,c("%d/%m/%Y %H:%M"))
# keep only the new time data
swazi_data <- select(swazi_data, New_time,long,lat,id,species,study)
swazi_data <- rename(swazi_data, time = New_time)
swazi_data
# check the minimum time and the maximum time
min_time <- swazi_data %>% group_by(id) %>% slice(which.min(time))
data.frame(min_time)
max_time <- swazi_data %>% group_by(id) %>% slice(which.max(time))
data.frame(max_time)
#' filter extreme data based on a speed threshold
#' based on vmax which is km/hr
#' time needs to be labelled DateTime for these functions to work
names(swazi_data)[names(swazi_data) == 'time'] <- 'DateTime'
SDLfilterData<-ddfilter.speed(data.frame(swazi_data), vmax = 60, method = 1)
length(SDLfilterData$DateTime)
#' rename everything as before
swazi_data <- SDLfilterData
names(swazi_data)[names(swazi_data) == 'DateTime'] <- 'time'
# try the amt package
trk <- mk_track(swazi_data, .x=long, .y=lat, .t=time, id = id, species=species,
crs = CRS("+init=epsg:4326"))
#' Save the class here (and apply it later after adding columns to the
#' object)
trk.class<-class(trk)
# nest by id
nesttrk<-trk%>%nest(-id)
nesttrk
#' Now, we need to again tell R that this is a track (rather
#' than just a data frame)
class(trk)
class(trk)<-trk.class
#' Lets take a look at what we created
trk <- trk %>% group_by(id)
trk
#' ## SSF prep
#'
#' SSFs assume that data have been collected at regular time intervals.
#' We can use the track_resample function to regularize the trajectory so that
#' all points are located within some tolerence of each other in time. To figure
#' out a meaningful tolerance range, we should calculate time differences between
#' locations & look at as a function of individual.
(timestats<-trk %>% nest(-id) %>% mutate(sr = map(data, summarize_sampling_rate)) %>%
dplyr::select(id, sr) %>% unnest)
#' add species names to the time intervals
timestats <- timestats %>%
left_join(trk %>%
distinct(id, species), by = 'id')
#' add the study name
timestats$study <- "swazi"
head(timestats)
#' make sure it matches up
filter(trk,id=="ID1") # wb
filter(trk,id=="ID2") # wb
head(timestats)
#' export the data
write.csv(timestats, file="track_resolution_summary/swazi_res.csv", row.names = FALSE)
#' let's select just the AWBVs
trk <- filter(trk,species=="wb")
trk
levels(as.factor(trk$species))
# need to run timestats again for the subsetted dataframe so that the IDs match up below
(timestats<-trk %>% nest(-id) %>% mutate(sr = map(data, summarize_sampling_rate)) %>%
dplyr::select(id, sr) %>% unnest)
#' Time intervals range depending on the individual.
#' Lets add on the time difference to each obs.
trk<-trk %>% group_by(id) %>% mutate(dt_ = t_ - lag(t_, default = NA))
trk
#+warning=FALSE
ssfdat<-NULL
temptrk<-with(trk, track(x=x_, y=y_, t=t_, id=id))
uid<-unique(trk$id) # individual identifiers
luid<-length(uid) # number of unique individuals
for(i in 1:luid){
# Subset individuals & regularize track
temp<-temptrk%>% filter(id==uid[i]) %>%
track_resample(rate=hours(1),
tolerance=minutes(10))
# Get rid of any bursts without at least 2 points
temp<-filter_min_n_burst(temp, 2)
# burst steps
stepstemp<-steps_by_burst(temp)
# create random steps using fitted gamma and von mises distributions and append
rnd_stps <- stepstemp %>%  random_steps(n = 15)
# append id
rnd_stps<-rnd_stps%>%mutate(id=uid[i])
# append new data to data from other individuals
ssfdat<-rbind(rnd_stps, ssfdat)
}
ssfdat<-as_tibble(ssfdat)
ssfdat
#' convert our regularised data back into a trk type data frame
home_range_data <-
ssfdat %>% filter(case_ == "TRUE") %>% select(x1_, y1_, t1_, id) %>% group_by(id)
home_range_trk <-
mk_track(
home_range_data,
.x = x1_,
.y = y1_,
.t = t1_,
id = id,
crs = CRS("+init=epsg:4326")
)
mcps <- home_range_trk %>% nest(-id) %>%
mutate(mcparea = map(data, ~ hr_mcp(., levels = c(0.95)) %>% hr_area)) %>%
select(id, mcparea) %>% unnest()
#+fig.height=12, fig.width=12, warning=FALSE, message=FALSE
ggplot(mcps, aes(x = id, y = area)) + geom_point() +
geom_smooth()
#' Same for KDE
kde <- home_range_trk %>% nest(-id) %>%
mutate(kdearea = map(data, ~ hr_kde(., levels = c(0.95)) %>% hr_area)) %>%
select(id, kdearea) %>% unnest()
#+fig.height=12, fig.width=12, warning=FALSE, message=FALSE
ggplot(kde, aes(x = id, y = kdearea)) + geom_point() +
geom_smooth()
?hr_kde
#' map the data
library(leaflet)
levels(as.factor(home_range_data$id))
leaflet() %>% addTiles() %>%
addCircleMarkers(
data = filter(home_range_data, id == "ID2"),
lat = ~ y1_,
lng = ~ x1_,
color = "blue"
)
#' save the map## 'mapview' objects (image below)
library(mapview)
install.packages("mapview")
#' save the map## 'mapview' objects (image below)
library(mapview)
leaflet() %>% addTiles() %>%
addCircleMarkers(
data = filter(home_range_data, id == "ID1"),
lat = ~ y1_,
lng = ~ x1_,
color = "blue"
)
#' save the map## 'mapview' objects (image below)
m <- leaflet() %>% addTiles() %>%
addCircleMarkers(
data = filter(home_range_data, id == "ID1"),
lat = ~ y1_,
lng = ~ x1_,
color = "blue"
)
getwd()
mapshot(m, file = paste0(getwd(), "/plots/Swazi_ID1.png"))
webshot::install_phantomjs()
mapshot(m, file = paste0(getwd(), "/plots/Swazi_ID1.png"))
#' save the map## 'mapview' objects (image below)
m <- leaflet() %>% addTiles() %>%
addCircleMarkers(
data = filter(home_range_data, id == "ID2"),
lat = ~ y1_,
lng = ~ x1_,
color = "blue"
)
library(mapview)
mapshot(m, file = paste0(getwd(), "/plots/Swazi_ID2.png"))
leaflet() %>% addTiles() %>%
addCircleMarkers(
data = filter(home_range_data, id == "ID2"),
lat = ~ y1_,
lng = ~ x1_,
color = "blue"
)
mapshot(m, file = paste0(getwd(), "/plots/Swazi_ID2.png"))
mapshot(m, file = paste0(getwd(), "/plots/Swazi_ID2.png"))
home_range_trk
#' convert to UTM
coordinates(xy) <- c("x_", "y_")
#' convert to UTM
coordinates(home_range_trk) <- c("x_", "y_")
mcps <- home_range_trk %>% nest(-id) %>%
mutate(mcparea = map(data, ~ hr_mcp(., levels = c(0.95)) %>% hr_area)) %>%
select(id, mcparea) %>% unnest()
home_range_trk <-
mk_track(
home_range_data,
.x = x1_,
.y = y1_,
.t = t1_,
id = id,
crs = CRS("+init=epsg:4326")
)
mcps <- home_range_trk %>% nest(-id) %>%
mutate(mcparea = map(data, ~ hr_mcp(., levels = c(0.95)) %>% hr_area)) %>%
select(id, mcparea) %>% unnest()
#+fig.height=12, fig.width=12, warning=FALSE, message=FALSE
ggplot(mcps, aes(x = id, y = area)) + geom_point() +
geom_smooth()
#' Same for KDE
kde <- home_range_trk %>% nest(-id) %>%
mutate(kdearea = map(data, ~ hr_kde(., levels = c(0.95)) %>% hr_area)) %>%
select(id, kdearea) %>% unnest()
#+fig.height=12, fig.width=12, warning=FALSE, message=FALSE
ggplot(kde, aes(x = id, y = kdearea)) + geom_point() +
geom_smooth()
?hr_kde
head(home_range_data$x1_[home_range_data$id == "ID1"])
head(home_range_data$y1_[home_range_data$id == "ID1"])
#' convert data to UTM
#' https://gis.stackexchange.com/questions/209267/r-return-the-utm-zone-that-a-wgs84-point-belongs-to
home_range_trk$zone <-
floor((home_range_trk$x_ + 180) / 6) + 1
home_range_trk
coordinates(home_range_trk) <- c("x_", "y_")
proj4string(xy) <- CRS("+proj=longlat +datum=WGS84")  ## for example
proj4string(home_range_trk) <- CRS("+proj=longlat +datum=WGS84")  ## for example
str(home_range_trk$zone)
summary(home_range_trk$zone)
#' convert to Africa Albers Equal Area Conic
#' https://epsg.io/102022
res <-
spTransform(
xy,
CRS(
"+proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m no_defs"
)
)
#' convert to Africa Albers Equal Area Conic
#' https://epsg.io/102022
res <-
spTransform(
home_range_trk,
CRS(
"+proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m no_defs"
)
)
res <-
spTransform(
home_range_trk,
CRS("+proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m no_defs"
)
)
#' convert to Africa Albers Equal Area Conic
#' https://epsg.io/102022
res <-
spTransform(
home_range_trk,
CRS("+proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
)
)
res
head(res)
plot(Res)
plot(res)
res[,1]
res[,2]
res[,3]
class(res)
data.frame(res)
res_data <- data.frame(res)
res_data
coordinates(home_range_trk) <- c("x_", "y_")
res_data
mcps <- res_data %>% nest(-id) %>%
mutate(mcparea = map(data, ~ hr_mcp(., levels = c(0.95)) %>% hr_area)) %>%
select(id, mcparea) %>% unnest()
names(res_data)
home_range_trk <-
mk_track(
home_range_data,
.x = x1_,
.y = y1_,
.t = t1_,
id = id,
crs = CRS(
"+proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
)
)
mcps <- home_range_trk %>% nest(-id) %>%
mutate(mcparea = map(data, ~ hr_mcp(., levels = c(0.95)) %>% hr_area)) %>%
select(id, mcparea) %>% unnest()
#+fig.height=12, fig.width=12, warning=FALSE, message=FALSE
ggplot(mcps, aes(x = id, y = area)) + geom_point() +
geom_smooth()
#' Same for KDE
kde <- home_range_trk %>% nest(-id) %>%
mutate(kdearea = map(data, ~ hr_kde(., levels = c(0.95)) %>% hr_area)) %>%
select(id, kdearea) %>% unnest()
#+fig.height=12, fig.width=12, warning=FALSE, message=FALSE
ggplot(kde, aes(x = id, y = kdearea)) + geom_point() +
geom_smooth()
home_range_trk
names(res_data)
home_range_trk <-
mk_track(
res_data,
.x = x1_,
.y = y1_,
.t = t1_,
id = id,
crs = CRS(
"+proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
)
)
names(res_data)
home_range_trk <-
mk_track(
res_data,
.x = x_,
.y = y_,
.t = t_,
id = id,
crs = CRS(
"+proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
)
)
home_range_trk
mcps <- home_range_trk %>% nest(-id) %>%
mutate(mcparea = map(data, ~ hr_mcp(., levels = c(0.95)) %>% hr_area)) %>%
select(id, mcparea) %>% unnest()
#+fig.height=12, fig.width=12, warning=FALSE, message=FALSE
ggplot(mcps, aes(x = id, y = area)) + geom_point() +
geom_smooth()
#' Same for KDE
kde <- home_range_trk %>% nest(-id) %>%
mutate(kdearea = map(data, ~ hr_kde(., levels = c(0.95)) %>% hr_area)) %>%
select(id, kdearea) %>% unnest()
#+fig.height=12, fig.width=12, warning=FALSE, message=FALSE
ggplot(kde, aes(x = id, y = kdearea)) + geom_point() +
geom_smooth()
#' map the data
library(leaflet)
levels(as.factor(home_range_data$id))
leaflet() %>% addTiles() %>%
addCircleMarkers(
data = filter(home_range_data, id == "ID2"),
lat = ~ y1_,
lng = ~ x1_,
color = "blue"
)
mcps
?hr_mcp
home_range_trk
#' We can add a columns to each nested column of data using purrr::map
trk<-home_range_trk %>% nest(-id) %>%
mutate(dir_abs = map(data, direction_abs,full_circle=TRUE, zero="N"),
dir_rel = map(data, direction_rel),
sl = map(data, step_lengths),
nsd_=map(data, nsd))%>%unnest()
trk
sqrt(675639)
