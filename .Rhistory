130.7,99.0,1,103.6),
sig2 = 100)
# Again, you can plot the modeled home range as with the Kernel Density
# Estimates.
image(morgan.bb)
# And you can make it into it's own raster object, to write it to an
# external file, etc.
X027 <- (raster(as(morgan.bb$X027, "SpatialPixelsDataFrame")))
# Plot the individual raster; you might need to close out of the previous
# plot for this to appear appropriately
plot(X027)
# Plot the individual raster; you might need to close out of the previous
# plot for this to appear appropriately
plot(X027)
# Extract the points for only individual X027
X027 <- morgan.spdf[morgan.spdf$id == "X027",]
# Plot those points on the raster
plot(X027, add = TRUE, cex = 0.01)
#' Get boundaries of 95% probability surface for a home range estimate
morganBB.95 <- getverticeshr(morgan.bb, 95, unout = "km2")
# Again, you can plot the modeled home range as with the Kernel Density
# Estimates.
image(morgan.bb)
likmorgan
plot(likmorgan)
likmorgan <- liker(morgan.traj, sig2 = 100, rangesig1 = c(1, 200))
morganBB.95[6,]
# Plot the bounds for the first individual (X027)
plot(morganBB.95[6,],
border = "red",
lwd = 2,
add = TRUE)
# Plot the individual raster; you might need to close out of the previous
# plot for this to appear appropriately
plot(X027)
# Plot the individual raster; you might need to close out of the previous
# plot for this to appear appropriately
plot(X027)
# Extract the points for only individual X027
X027 <- morgan.spdf[morgan.spdf$id == "X027",]
# Plot those points on the raster
plot(X027, add = TRUE, cex = 0.01)
#' Get boundaries of 95% probability surface for a home range estimate
morganBB.95 <- getverticeshr(morgan.bb, 95, unout = "km2")
# Plot the bounds for the first individual (X027)
plot(morganBB.95[6,],
border = "red",
lwd = 2,
add = TRUE)
#' As with the prevous home range estimators, you can also extract the area of the specified home range for the
#' Brownian Bridge Movement Model based at the desired level (we will use the 95% level again):
morganBB.95@data
# Plot the individual raster; you might need to close out of the previous
# plot for this to appear appropriately
plot(X027)
# Extract the points for only individual X027
X027 <- morgan.spdf[morgan.spdf$id == "X027",]
# Plot those points on the raster
plot(X027, add = TRUE, cex = 0.01)
# Extract the points for only individual X027
X027 <- morgan.spdf[morgan.spdf$id == "X027",]
# Plot those points on the raster
plot(X027, add = TRUE, cex = 0.01)
# Plot the individual raster; you might need to close out of the previous
# plot for this to appear appropriately
plot(X027)
# Extract the points for only individual X027
X027 <- morgan.spdf[morgan.spdf$id == "X027",]
# Plot those points on the raster
plot(X027, add = TRUE, cex = 0.01)
#' Get boundaries of 95% probability surface for a home range estimate
morganBB.95 <- getverticeshr(morgan.bb, 95, unout = "km2")
# Plot the bounds for the first individual (X027)
plot(morganBB.95[6,],
border = "red",
lwd = 2,
add = TRUE)
#' As with the prevous home range estimators, you can also extract the area of the specified home range for the
#' Brownian Bridge Movement Model based at the desired level (we will use the 95% level again):
morganBB.95@data
?brownian.bridge.dyn
require(move)
move_test <- filter(swazi_data, id == "ID1")
rm(ind2)
rm(swazi.spdf)
rm(morgan.spdf)
rm(temp1)
rm(temp2)
rm(SDLfilterData)
rm(morgan.traj)
rm(morgan.Khref)
rm(X027)
head(move_test)
class(move_test$time)
ss1 <- move(x=move_test$long, y=move_test$lat, time= move_test$time,  proj=CRS("+proj=longlat +ellps=WGS84"),data=move_test, animal="ID1")
ss1
#' transform into a spatial points object
r <- spTransform(ss1, center=T)
r
ID1_dbbmm <- brownian.bridge.dyn(
r,
dimSize = 150,
location.error = 23,
ext = 1,
time.step = 60,
margin = 13
)
?move
?brownian.bridge.dyn
ID1_dbbmm <- brownian.bridge.dyn(
r,
dimSize = 150,
location.error = 0.0001,
ext = 1,
#  time.step = 60,
margin = 15
)
#' take a sample of data so it runs
move_test <- head(move_test,500)
#' transform into a move object
ss1 <-
move(
x = move_test$long,
y = move_test$lat,
time = move_test$time,
proj = CRS("+proj=longlat +ellps=WGS84"),
data = move_test,
animal = "ID1"
)
#' take a look
ss1
#' transform into a spatial points object
r <- spTransform(ss1, center = T)
r
ID1_dbbmm <- brownian.bridge.dyn(
r,
dimSize = 150,
location.error = 0.0001,
ext = 1,
#  time.step = 60,
margin = 15
)
ID1_dbbmm
plot(ID1_dbbmm, xlab="location_long", ylab="location_lat")
lines(spTransform(ricky[1:500,], center=TRUE), col=3, lwd=2)
plot(move_test$long, move_test$lat)
contour(ID1_dbbmm, levels=c(.5, .95), col=c(6,2), add=TRUE, lwd=2)
ID1_cont <- getVolumeUD(ID1_dbbmm)
ID1_cont <- ID1_cont<=.95
area <- sum(values(ID1_cont))
area
library(sp)
# load data provided from the online repository
fulmarURL <- "https://datadryad.org/bitstream/handle/10255/dryad.174482/"
fileName <- "Fulmar_trackingData.csv?sequence=1"
raw_data <- read.csv(url(paste0(fulmarURL,fileName)),
stringsAsFactors = FALSE)
raw_data$ID <- raw_data$tripID
raw_data$Date <- as.POSIXct(raw_data$Date,tz="UTC",
format="%d/%m/%Y %H:%M")
# project data
oldProj <- CRS("+proj=longlat +datum=WGS84")
newProj <- CRS("+init=epsg:27700")
coordinates(raw_data) <- c("Longitude","Latitude")
proj4string(raw_data) <- oldProj
raw_data <- as.data.frame(spTransform(raw_data, newProj))
coordinates(raw_data) <- c("Boat_Longitude","Boat_Latitude")
proj4string(raw_data) <- oldProj
raw_data <- as.data.frame(spTransform(raw_data, newProj))
library(sp)
# load data provided from the online repository
fulmarURL <- "https://datadryad.org/bitstream/handle/10255/dryad.174482/"
fileName <- "Fulmar_trackingData.csv?sequence=1"
raw_data <- read.csv(url(paste0(fulmarURL,fileName)),
stringsAsFactors = FALSE)
#' we rename some of the column names
raw_data$ID <- raw_data$tripID
#' we format the date
raw_data$Date <- as.POSIXct(raw_data$Date,tz="UTC",
format="%d/%m/%Y %H:%M")
#' we project data from longitude and latitude to a different type of projection system that is in metres
oldProj <- CRS("+proj=longlat +datum=WGS84")
newProj <- CRS("+init=epsg:27700")
#' we specify the coordinates
coordinates(raw_data) <- c("Longitude","Latitude")
proj4string(raw_data) <- oldProj
raw_data <- as.data.frame(spTransform(raw_data, newProj))
raw_data
rm(ls=list())
rm(ls==list())
rm(list=ls())
?require
list.of.packages <- c("sp", "tidyverse")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
library(sp)
library(tidyverse)
fulmarURL <- "https://datadryad.org/bitstream/handle/10255/dryad.174482/"
fileName <- "Fulmar_trackingData.csv?sequence=1"
raw_data <- read.csv(url(paste0(fulmarURL,fileName)),
stringsAsFactors = FALSE)
rm(raw_data)
head(mydata)
mydata <- read.csv(url(paste0(fulmarURL,fileName)),
stringsAsFactors = FALSE)
head(mydata)
#' pick the relevant columns using the select function
mydata <- select(birdID, tripID, Longitude, Latitude, Date)
#' pick the relevant columns using the select function
mydata <- mydata %>% select(birdID, tripID, Longitude, Latitude, Date)
#' plot the tracks
qmplot(Longitude,
Latitude,
data = mydata,
maptype = "toner-lite",
colour = birdID)
library(ggmap)
#' plot the tracks by birdID
qmplot(Longitude,
Latitude,
data = mydata,
maptype = "toner-lite",
colour = birdID)
#' plot the tracks by birdID
qmplot(Longitude,
Latitude,
data = mydata,
maptype = "toner-lite",
colour = as.factor(birdID))
#' Now plot the tracks by tripID
#' some birds went out on multiple foraging trips
qmplot(Longitude,
Latitude,
data = mydata,
maptype = "toner-lite",
colour = as.factor(tripID))
qmplot(
Longitude,
Latitude,
data = mydata,
maptype = "toner-background",
colour = as.factor(birdID)
) +  facet_wrap( ~ id)
qmplot(
Longitude,
Latitude,
data = mydata,
maptype = "toner-background",
colour = as.factor(birdID)
) +  facet_wrap( ~ as.factor(birdID))
qmplot(
Longitude,
Latitude,
data = mydata,
maptype = "toner-lite",
colour = as.factor(birdID)
)
qmplot(
Longitude,
Latitude,
data = mydata,
maptype = "toner-background",
colour = as.factor(birdID)
) +  facet_wrap( ~ (birdID))
#' Now plot each bird on its own map
#' plot each track on a separate panel using facet
qmplot(
Longitude,
Latitude,
data = mydata,
maptype = "toner-background",
colour = as.factor(birdID)
) +  facet_wrap( ~ (mydata$birdID))
qmplot(
Longitude,
Latitude,
data = mydata,
maptype = "toner-background",
colour = as.factor(birdID)
) +  facet_wrap( ~ (as.factor(mydata$birdID)))
(qmplot(Longitude,
Latitude,
data = mydata,
maptype = "toner-background",
colour = as.factor(birdID)
) +    facet_wrap( ~ as.factor(birdID)))
#' plot each track on a separate panel using facet
qmplot(Longitude,
Latitude,
data = mydata,
maptype = "toner-background",
colour = as.factor(birdID)
) + facets = .~ as.factor(birdID))
qmplot(Longitude,
Latitude,
data = mydata,
maptype = "toner-background",
colour = as.factor(birdID)
) + facets = .~ as.factor(birdID)
qmplot(Longitude,
Latitude,
data = mydata,
maptype = "toner-background",
colour = as.factor(birdID)
)
qmplot(Longitude,
Latitude,
data = mydata,
maptype = "toner-background",
colour = as.factor(birdID)
) + facet_wrap = .~ as.factor(birdID)
(
qmplot(
Longitude,
Latitude,
data = mydata,
maptype = "toner-background",
colour = as.factor(birdID)
) +
facet_wrap( ~ as.factor(birdID))
)
#' plot the data with no background
ggplot(data = mydata, mapping = aes(x = Longitude, y = Latitude)) + geom_point()
#' plot the data with no background
ggplot(data = mydata, mapping = aes(x = Longitude, y = Latitude)) + geom_point(color = as.factor(birdID))
#' plot the data with no background
ggplot(data = mydata, mapping = aes(x = Longitude, y = Latitude, color = as.factor(birdID))) + geom_point()
mydata$birdID <- as.factor(mydata$birdID)
mydata$birdID <- as.factor(mydata$birdID)
#' plot the data with no background
ggplot(data = mydata, mapping = aes(x = Longitude, y = Latitude, color = birdID)) + geom_point()
#' plot the tracks by birdID
qmplot(Longitude,
Latitude,
data = mydata,
maptype = "toner-lite",
colour = birdID)
qmplot(Longitude,
Latitude,
data = mydata,
maptype = "toner-lite",
colour = birdID,
zoom = 10)
qmplot(Longitude,
Latitude,
data = mydata,
maptype = "toner-lite",
colour = birdID)
(
qmplot(
Longitude,
Latitude,
data = mydata,
maptype = "toner-background",
colour = birdID
) +
facet_wrap( ~ birdID)
)
filter(mydata, tripID == "1")
levels(mydata$tripID)
levels(as.factor(mydata$tripID))
view(mydata)
View(mydata)
#' Only one bird went on more than one trip
#' let's remove its second trip so we're comparing
#' like with like across all of the birds
mydata  <- mydata %>% filter(birdID == "1" & tripID == "1")
levels(mydata$tripID)
mydata$tripID <- as.factor(mydata$tripID)
levels(mydata$tripID)
list.of.packages <- c("sp", "tidyverse", "ggmap")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
library(sp)
library(tidyverse)
library(ggmap)
# load data provided from the online repository
fulmarURL <- "https://datadryad.org/bitstream/handle/10255/dryad.174482/"
fileName <- "Fulmar_trackingData.csv?sequence=1"
mydata <- read.csv(url(paste0(fulmarURL,fileName)),
stringsAsFactors = FALSE)
head(mydata)
#' pick the relevant columns using the select function
mydata <- mydata %>% select(birdID, tripID, Longitude, Latitude, Date)
#' make the birdID and tripID columns factors because they identify the individual birds and their trips
mydata$birdID <- as.factor(mydata$birdID)
mydata$tripID <- as.factor(mydata$tripID)
#' Only one bird went on more than one trip
#' let's remove its second trip so we're comparing
#' like with like across all of the birds
mydata  <- mydata %>% filter(!tripID == "1")
levels(mydata$tripID)
mydata
list.of.packages <- c("sp", "tidyverse", "ggmap")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
library(sp)
library(tidyverse)
library(ggmap)
# load data provided from the online repository
fulmarURL <- "https://datadryad.org/bitstream/handle/10255/dryad.174482/"
fileName <- "Fulmar_trackingData.csv?sequence=1"
mydata <- read.csv(url(paste0(fulmarURL,fileName)),
stringsAsFactors = FALSE)
head(mydata)
#' pick the relevant columns using the select function
mydata <- mydata %>% select(birdID, tripID, Longitude, Latitude, Date)
#' make the birdID and tripID columns factors because they identify the individual birds and their trips
mydata$birdID <- as.factor(mydata$birdID)
mydata$tripID <- as.factor(mydata$tripID)
#' Only one bird went on more than one trip
#' let's remove its second trip so we're comparing
#' like with like across all of the birds
mydata  <- mydata %>% filter(!tripID == "1") %>%   droplevels()
levels(mydata$tripID)
?qmplot
#' Now plot each bird on its own map
#' plot each track on a separate panel using facet
(
qmplot(
Longitude,
Latitude,
data = mydata,
maptype = "terrain-background",
colour = birdID
) +
facet_wrap( ~ birdID)
)
#' Now plot each bird on its own map
#' plot each track on a separate panel using facet
(
qmplot(
Longitude,
Latitude,
data = mydata,
maptype = "satellite",
colour = birdID
) +
facet_wrap( ~ birdID)
)
#' Now plot each bird on its own map
#' plot each track on a separate panel using facet
(
qmplot(
Longitude,
Latitude,
data = mydata,
maptype = "satellite",
colour = birdID
) +
facet_wrap( ~ birdID)
)
?get_stamenmap
#' Now plot each bird on its own map
#' plot each track on a separate panel using facet
(
qmplot(
Longitude,
Latitude,
data = mydata,
maptype = "terrain",
colour = birdID
) +
facet_wrap( ~ birdID)
)
?distCosine
library(spatial)
mydata
distance_function<-function(x){max(distCosine(c(-3.119722,59.144722), cbind(x$Longitude, x$Latitude)))/1000}
sapply(split(mydata[3:4],mydata$birdID), distance_function)
library(spatial)
distance_function<-function(x){max(distCosine(c(-3.119722,59.144722), cbind(x$Longitude, x$Latitude)))/1000}
sapply(split(mydata[3:4],mydata$birdID), distance_function)
?distCosine
library(geosphere)
distance_function<-function(x){max(distCosine(c(-3.119722,59.144722), cbind(x$Longitude, x$Latitude)))/1000}
sapply(split(mydata[3:4],mydata$birdID), distance_function)
mydata %>% group_by(birdID) %>% select(Longitude, Latitude) %>% distance_function
mydata %>% group_by(birdID) %>% select(Longitude, Latitude) %>% distance_function
mydata %>% group_by(birdID) %>% select(Longitude, Latitude)
mydata %>% group_by(birdID) %>% select(Longitude, Latitude) %>% do_(. distance_function)
mydata %>% group_by(birdID) %>% select(Longitude, Latitude) %>% do_(., distance_function)
#' this is a custom function which takes the colony coordinates and the data from our tracks
#' It uses these data to calculate the maximum distance from the colony using distCosine, a function from the package geosphere
distance_function<-function(x){max(distCosine(c(-3.119722,59.144722), cbind(x$Longitude, x$Latitude)))/1000}
#' we extract the columns that correspond to longitude and latitude and apply our function to each birdID separately
sapply(split(mydata[3:4],mydata$birdID), distance_function)
write.table(mydata, "fulmar.csv", row.names = F)
distm (c(-3.119722,59.144722), c(mydata$Longitude, mydata$Latitude), fun = distHaversine)
distm (c(-3.119722,59.144722), c(-3.119722, 60), fun = distHaversine)
distm (c(-3.119722,59.144722), c(-3.119722, 60), fun = distHaversine) / 1000
distm (c(-3.119722,59.144722), c(0.24, 57.6), fun = distHaversine) / 1000
#' we extract the columns that correspond to longitude and latitude and apply our function to each birdID separately
sapply(split(mydata[3:4],mydata$birdID), distance_function)
data(puechcirc)
x <- puechcirc[1]
x
library(adehabitatHR)
data(puechcirc)
x <- puechcirc[1]
x
lik <- liker(x, sig2 = 58, rangesig1 = c(1, 10))
tata <- kernelbb(x, sig1 = 6.23, sig2 = 58, grid = 50)
tata
image(tata)
plot(getverticeshr(tata, 95), add=TRUE, lwd=2)
data
puechcirc
x
puechcirc[1]
bb.95 <- getverticeshr(tata, percent = 95)
bb.95
