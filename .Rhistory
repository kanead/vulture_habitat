opts_chunk$set(fig.width=12,fig.height=4.5, error=TRUE,cache = F)
#' Record time for running all code
ptm<-proc.time()
#' Set the seed for the random number generator, so it will be possible
#' to reproduce the random points
set.seed(10299)
#' Create a login object for a user account at movebank.org
loginStored <- movebankLogin(username="MovebankWorkshop", password="genericuserforthisexercise")
getMovebankStudy(study="Martes pennanti LaPoint New York", login=loginStored) # see study-level info
#' Load data from a study in Movebank and create a MoveStack object. For more details and options see https://cran.r-project.org/web/packages/move/index.html.
fisher.move <- getMovebankData(study="Martes pennanti LaPoint New York", login=loginStored)
head(fisher.move)
#' Create a data frame from the MoveStack object
fisher.dat <- as(fisher.move, "data.frame")
#' Delete observations where missing lat or long or a timestamp.  There are no missing
#' observations in this data set, but it is still good practice to check.
ind<-complete.cases(fisher.dat[,c("location_lat", "location_long", "timestamp")])
fisher.dat<-fisher.dat[ind==TRUE,]
#' Check for duplicated observations (ones with same lat, long, timestamp,
#'  and individual identifier). There are no duplicate
#' observations in this data set, but it is still good practice to check.
ind2<-fisher.dat %>% dplyr::select(timestamp, location_long, location_lat, local_identifier) %>%
duplicated
sum(ind2) # no duplicates
fisher.dat<-fisher.dat[ind2!=TRUE,]
#' Make timestamp a date/time variable
fisher.dat$timestamp<-as.POSIXct(fisher.dat$timestamp, format="%Y-%m-%d %H:%M:%OS", tz="UTC")
#' Look at functions in the move package.
plot(fisher.move)
show(fisher.move)
summary(fisher.move)
fisherF2<-fisher.dat %>% filter(local_identifier=="F2")
z<-(calc_zoom(location_long, location_lat, fisherF2))
map <- get_map(location = c(lon = mean(fisherF2$location_long),
lat = mean(fisherF2$location_lat)), zoom = 12,
maptype = "hybrid", source = "google")
ggmap(map) +
geom_point(data=fisherF2, aes(x=location_long, y=location_lat), size=2.5)
#' Now, using leaflet
leaflet(fisherF2)%>%addTiles()%>%
addCircles(fisherF2$location_long, fisherF2$location_lat)
#' ### Using ggplot without a background
#'
#' Use separate axes for each individual (add scales="free" to facet_wrap)
#+fig.height=12, fig.width=12
ggplot(fisher.dat, aes(x=location_long, y=location_lat))+geom_point()+
facet_wrap(~local_identifier, scales="free")
#' Now, all on 1 plot
#+fig.height=6, fig.width=12
ggplot(fisher.dat, aes(x=location_long, y=location_lat, color=as.factor(local_identifier)))+
geom_point()
#' We can also use lat, long, which will allow us to determine
#' time of day
trk <- mk_track(fisher.dat, .x=location_long, .y=location_lat, .t=timestamp, id = local_identifier,
crs = CRS("+init=epsg:4326"))
# Now it is easy to calculate day/night with either movement track
trk <- trk %>% time_of_day()
#' Now, we can transform back to geographic coordinates
trk <- transform_coords(trk, CRS("+init=epsg:32618"))
#' Save the class here (and apply it later after adding columns to the
#' object)
trk.class<-class(trk)
#' individual (to avoid calculating a distance between say the last observation
#' of the first individual and the first observation of the second individual).
#'
#'
#' To do this, we could loop through individuals, calculate these
#' characteristics for each individual, then rbind the data
#' back together.  Or, use nested data frames and the map function
#' in the purrr library to do this with very little code.
#'
#' To see how nesting works, we can create a nested object by individual
nesttrk<-trk%>%nest(-id)
nesttrk
#' Each row contains data from an individual.  For example, we can access data
#' from the first individual using:
nesttrk$data[[1]]
#' We could calculate movement characteristics by individual using:
temp<-direction_rel(nesttrk$data[[1]])
head(temp)
#' or:
temp<-trk %>% filter(id=="M1") %>% direction_rel
head(temp)
#' Or, we can add a columns to each nested column of data using purrr::map
trk<-trk %>% nest(-id) %>%
mutate(dir_abs = map(data, direction_abs,full_circle=TRUE, zero="N"),
dir_rel = map(data, direction_rel),
sl = map(data, step_lengths),
nsd_=map(data, nsd))%>%unnest()
#' Now, calculate month, year, hour, week of each observation and append these to the dataset
#' Unlike the movement charactersitics, these calculations can be done all at once,
#' since they do not utilize successive observations (like step lengths and turn angles do).
trk<-trk%>%
mutate(
week=week(t_),
month = month(t_, label=TRUE),
year=year(t_),
hour = hour(t_)
)
#' Now, we need to again tell R that this is a track (rather
#' than just a data frame)
class(trk)
class(trk)<-trk.class
#' Lets take a look at what we created
trk
#' Notes:
#'
#' - It is common to generate points randomly, but other options are possible.
#' - In particular, it can beneficial to generate a systematically placed sample
#' - Samples can also be generated using the *spsample* function in the sp library or
#' using a GIS (note: amt uses the spsample function within its function random_points)
#' - Other home range polygons could be used (e.g., kernel density, local convex hull
#' etc.)
#'
#' #### Random points: illustrate for 1 individual
trk %>% filter(id=="F1") %>%
random_points(.,factor = 20) %>% plot
#' Illustrate systematic points (to do this, we need to create the mcp first)
trk%>%filter(id=="F1") %>%
random_points(., factor = 20, type="regular") %>%
plot()
#' Now, lets generate points for all individuals. We can do this
#' efficiently by making use of pipes (%>%),nested data frames, and
#' then by adding a new column -- a list-column -- to trks
avail.pts <- trk %>% nest(-id) %>%
mutate(rnd_pts = map(data, ~ random_points(., factor = 20, type="regular"))) %>%
select(id, rnd_pts) %>%  # you dont want to have the original point twice, hence drop data
unnest()
#' Now, lets generate points for all individuals. We can do this
#' efficiently by making use of pipes (%>%),nested data frames, and
#' then by adding a new column -- a list-column -- to trks
avail.pts <- trk %>% nest(-id) %>%
mutate(rnd_pts = map(data, ~ random_points(., factor = 20, type="regular"))) %>%
dplyr::select(id, rnd_pts) %>%  # you dont want to have the original point twice, hence drop data
unnest()
#'
#' Need to rename variables so everything is in the format Movebank requires for annotation of generic time-location
#' records (see https://www.movebank.org/node/6608#envdata_generic_request). This means, we need the following variables:
#'
#' - location-lat (perhaps with addition of Easting/Northing in UTMs)
#' - location-long (perhaps with addition of Easting/Northing in UTMs)
#' - timestamp (in Movebank format)
#'
#' Need to project to lat/long, while also keeping lat/long. Then rename
#' variables and write out the data sets.
avail <- SpatialPointsDataFrame(avail.pts[,c("x_","y_")], avail.pts,
proj4string=CRS("+proj=utm +zone=18N +datum=WGS84"))
avail.df <- data.frame(spTransform(avail, CRS("+proj=longlat +datum=WGS84")))[,1:6]
names(avail.df)<-c("idr", "case_", "utm.easting", "utm.northing", "location-long", "location-lat")
#' Check to make sure everything looks right
test<-subset(avail.df, case_==TRUE)
test %>% select('location-lat', 'location-long', utm.easting, utm.northing) %>%
summarise_all(mean)
fisher.dat %>% summarize(meanloc.lat=mean(location_lat),
meanloc.long=mean(location_long))
#' Check to make sure everything looks right
test<-subset(avail.df, case_==TRUE)
test %>% dplyr::select('location-lat', 'location-long', utm.easting, utm.northing) %>%
summarise_all(mean)
fisher.dat %>% summarize(meanloc.lat=mean(location_lat),
meanloc.long=mean(location_long))
#' Add a timestamp to annotate these data with environmental covariates in Movebank using Env-DATA (https://www.movebank.org/node/6607).
#' Here we just use the first timestamp, however meaningful timestamps are needed if annotating variables that vary in time.
avail.df$timestamp<-fisher.dat$timestamp[1]
#' ## SSF prep
#'
#' SSFs assume that data have been collected at regular time intervals.
#' We can use the track_resample function to regularize the trajectory so that
#' all points are located within some tolerence of each other in time. To figure
#' out a meaningful tolerance range, we should calculate time differences between
#' locations & look at as a function of individual.
(timestats<-trk %>% nest(-id) %>% mutate(sr = map(data, summarize_sampling_rate)) %>%
select(id, sr) %>% unnest)
#' ## SSF prep
#'
#' SSFs assume that data have been collected at regular time intervals.
#' We can use the track_resample function to regularize the trajectory so that
#' all points are located within some tolerence of each other in time. To figure
#' out a meaningful tolerance range, we should calculate time differences between
#' locations & look at as a function of individual.
(timestats<-trk %>% nest(-id) %>% mutate(sr = map(data, summarize_sampling_rate)) %>%
dplyr:: select(id, sr) %>% unnest)
#' Time intervals range from every 2 to 15 minutes on average, depending
#' on the individual.  Lets add on the time difference to each obs.
trk<-trk %>% group_by(id) %>% mutate(dt_ = t_ - lag(t_, default = NA))
#' Let's illustrate track regularization with ID = F2. Let's
#' go from every 2 minutes to every 10.
tempF2<-trk %>% filter(id=="F2") %>% track_resample(rate=minutes(10), tolerance=minutes(2))
tempF2 %>% select(id, x_, y_, t_, burst_)
#' Let's illustrate track regularization with ID = F2. Let's
#' go from every 2 minutes to every 10.
tempF2<-trk %>% filter(id=="F2") %>% track_resample(rate=minutes(10), tolerance=minutes(2))
tempF2 %>% dplyr::select(id, x_, y_, t_, burst_)
#+warning=FALSE
ssfdat<-NULL
temptrk<-with(trk, track(x=x_, y=y_, t=t_, id=id))
uid<-unique(trk$id) # individual identifiers
luid<-length(uid) # number of unique individuals
for(i in 1:luid){
# Subset individuals & regularize track
temp<-temptrk%>% filter(id==uid[i]) %>%
track_resample(rate=minutes(round(timestats$median[i])),
tolerance=minutes(max(10,round(timestats$median[i]/5))))
# Get rid of any bursts without at least 2 points
temp<-filter_min_n_burst(temp, 2)
# burst steps
stepstemp<-steps_by_burst(temp)
# create random steps using fitted gamma and von mises distributions and append
rnd_stps <- stepstemp %>%  random_steps(n = 15)
# append id
rnd_stps<-rnd_stps%>%mutate(id=uid[i])
# append new data to data from other individuals
ssfdat<-rbind(rnd_stps, ssfdat)
}
#' Load libraries
#+warning=FALSE, message=FALSE
library(knitr)
library(lubridate)
library(raster)
library(move)
library(amt)
library(ggmap)
library(tibble)
library(dplyr)
#' Create a login object for a user account at movebank.org
loginStored <- movebankLogin(username="MovebankWorkshop", password="genericuserforthisexercise")
#' Get overview information about a Movebank study. Be sure to check the citation and license terms if not using your own data.
getMovebankStudy(study="Martes pennanti LaPoint New York", login=loginStored) # see study-level info
#' Load data from a study in Movebank and create a MoveStack object. For more details and options see https://cran.r-project.org/web/packages/move/index.html.
fisher.move <- getMovebankData(study="Martes pennanti LaPoint New York", login=loginStored)
head(fisher.move)
#' Create a data frame from the MoveStack object
fisher.dat <- as(fisher.move, "data.frame")
#' ### Data cleaning
ind<-complete.cases(fisher.dat[,c("location_lat", "location_long", "timestamp")])
fisher.dat<-fisher.dat[ind==TRUE,]
ind2<-fisher.dat %>% select(timestamp, location_long, location_lat, local_identifier) %>%
duplicated
sum(ind2) # no duplicates
fisher.dat<-fisher.dat[ind2!=TRUE,]
#' Make timestamp a date/time variable
fisher.dat$timestamp<-as.POSIXct(fisher.dat$timestamp, format="%Y-%m-%d %H:%M:%OS", tz="UTC")
#' ## Creating a track in amt
trk <- mk_track(fisher.dat, .x=location_long, .y=location_lat, .t=timestamp, id = local_identifier,
crs = CRS("+init=epsg:4326"))
# Now it is easy to calculate day/night with either movement track
trk <- trk %>% time_of_day()
#' Now, we can transform back to geographic coordinates
trk <- transform_coords(trk, CRS("+init=epsg:32618"))
trk.class<-class(trk)
nesttrk<-trk%>%nest(-id)
nesttrk
trk<-trk %>% nest(-id) %>%
mutate(dir_abs = map(data, direction_abs,full_circle=TRUE, zero="N"),
dir_rel = map(data, direction_rel),
sl = map(data, step_lengths),
nsd_=map(data, nsd))%>%unnest()
trk<-trk%>%
mutate(
week=week(t_),
month = month(t_, label=TRUE),
year=year(t_),
hour = hour(t_)
)
class(trk)
class(trk)<-trk.class
#' Lets take a look at what we created
trk
#' ## SSF prep
(timestats<-trk %>% nest(-id) %>% mutate(sr = map(data, summarize_sampling_rate)) %>%
select(id, sr) %>% unnest)
#' Time intervals range from every 2 to 15 minutes on average, depending
#' on the individual.  Lets add on the time difference to each obs.
trk<-trk %>% group_by(id) %>% mutate(dt_ = t_ - lag(t_, default = NA))
ssfdat<-NULL
temptrk<-with(trk, track(x=x_, y=y_, t=t_, id=id))
uid<-unique(trk$id) # individual identifiers
luid<-length(uid) # number of unique individuals
for(i in 1:luid){
# Subset individuals & regularize track
temp<-temptrk%>% filter(id==uid[i]) %>%
track_resample(rate=minutes(round(timestats$median[i])),
tolerance=minutes(max(10,round(timestats$median[i]/5))))
# Get rid of any bursts without at least 2 points
temp<-filter_min_n_burst(temp, 2)
# burst steps
stepstemp<-steps_by_burst(temp)
# create random steps using fitted gamma and von mises distributions and append
rnd_stps <- stepstemp %>%  random_steps(n = 15)
# append id
rnd_stps<-rnd_stps%>%mutate(id=uid[i])
# append new data to data from other individuals
ssfdat<-rbind(rnd_stps, ssfdat)
}
ssfdat<-as_tibble(ssfdat)
ssfdat
conflicts()
head(fisher.move)
#' Create a data frame from the MoveStack object
fisher.dat <- as(fisher.move, "data.frame")
#' ### Data cleaning
ind<-complete.cases(fisher.dat[,c("location_lat", "location_long", "timestamp")])
fisher.dat<-fisher.dat[ind==TRUE,]
ind2<-fisher.dat %>% dplyr::select(timestamp, location_long, location_lat, local_identifier) %>%
duplicated
sum(ind2) # no duplicates
fisher.dat<-fisher.dat[ind2!=TRUE,]
#' Make timestamp a date/time variable
fisher.dat$timestamp<-as.POSIXct(fisher.dat$timestamp, format="%Y-%m-%d %H:%M:%OS", tz="UTC")
#' ## Creating a track in amt
trk <- mk_track(fisher.dat, .x=location_long, .y=location_lat, .t=timestamp, id = local_identifier,
crs = CRS("+init=epsg:4326"))
# Now it is easy to calculate day/night with either movement track
trk <- trk %>% time_of_day()
#' Now, we can transform back to geographic coordinates
trk <- transform_coords(trk, CRS("+init=epsg:32618"))
trk.class<-class(trk)
nesttrk<-trk%>%nest(-id)
nesttrk
trk<-trk %>% nest(-id) %>%
mutate(dir_abs = map(data, direction_abs,full_circle=TRUE, zero="N"),
dir_rel = map(data, direction_rel),
sl = map(data, step_lengths),
nsd_=map(data, nsd))%>%unnest()
trk<-trk%>%
mutate(
week=week(t_),
month = month(t_, label=TRUE),
year=year(t_),
hour = hour(t_)
)
class(trk)
class(trk)<-trk.class
#' Lets take a look at what we created
trk
(timestats<-trk %>% nest(-id) %>% mutate(sr = map(data, summarize_sampling_rate)) %>%
select(id, sr) %>% unnest)
(timestats<-trk %>% nest(-id) %>% mutate(sr = map(data, summarize_sampling_rate)) %>%
dplyr::select(id, sr) %>% unnest)
#' Time intervals range from every 2 to 15 minutes on average, depending
#' on the individual.  Lets add on the time difference to each obs.
trk<-trk %>% group_by(id) %>% mutate(dt_ = t_ - lag(t_, default = NA))
ssfdat<-NULL
temptrk<-with(trk, track(x=x_, y=y_, t=t_, id=id))
uid<-unique(trk$id) # individual identifiers
luid<-length(uid) # number of unique individuals
for(i in 1:luid){
# Subset individuals & regularize track
temp<-temptrk%>% filter(id==uid[i]) %>%
track_resample(rate=minutes(round(timestats$median[i])),
tolerance=minutes(max(10,round(timestats$median[i]/5))))
# Get rid of any bursts without at least 2 points
temp<-filter_min_n_burst(temp, 2)
# burst steps
stepstemp<-steps_by_burst(temp)
# create random steps using fitted gamma and von mises distributions and append
rnd_stps <- stepstemp %>%  random_steps(n = 15)
# append id
rnd_stps<-rnd_stps%>%mutate(id=uid[i])
# append new data to data from other individuals
ssfdat<-rbind(rnd_stps, ssfdat)
}
#' Load libraries
library(knitr)
library(lubridate)
library(raster)
library(move)
library(amt)
library(ggmap)
library(tibble)
library(dplyr)
#' Create a login object for a user account at movebank.org
loginStored <- movebankLogin(username="MovebankWorkshop", password="genericuserforthisexercise")
#' Get overview information about a Movebank study. Be sure to check the citation and license terms if not using your own data.
getMovebankStudy(study="Martes pennanti LaPoint New York", login=loginStored) # see study-level info
#' Load data from a study in Movebank and create a MoveStack object. For more details and options see https://cran.r-project.org/web/packages/move/index.html.
fisher.move <- getMovebankData(study="Martes pennanti LaPoint New York", login=loginStored)
head(fisher.move)
#' Create a data frame from the MoveStack object
fisher.dat <- as(fisher.move, "data.frame")
#' ### Data cleaning
ind<-complete.cases(fisher.dat[,c("location_lat", "location_long", "timestamp")])
fisher.dat<-fisher.dat[ind==TRUE,]
#' Make timestamp a date/time variable
fisher.dat$timestamp<-as.POSIXct(fisher.dat$timestamp, format="%Y-%m-%d %H:%M:%OS", tz="UTC")
#' ## Creating a track in amt
trk <- mk_track(fisher.dat, .x=location_long, .y=location_lat, .t=timestamp, id = local_identifier,
crs = CRS("+init=epsg:4326"))
# Now it is easy to calculate day/night with either movement track
trk <- trk %>% time_of_day()
#' Now, we can transform back to geographic coordinates
trk <- transform_coords(trk, CRS("+init=epsg:32618"))
trk.class<-class(trk)
nesttrk<-trk%>%nest(-id)
trk<-trk %>% nest(-id) %>%
mutate(dir_abs = map(data, direction_abs,full_circle=TRUE, zero="N"),
dir_rel = map(data, direction_rel),
sl = map(data, step_lengths),
nsd_=map(data, nsd))%>%unnest()
trk<-trk%>%
mutate(
week=week(t_),
month = month(t_, label=TRUE),
year=year(t_),
hour = hour(t_)
)
class(trk)<-trk.class
#' ## SSF prep
(timestats<-trk %>% nest(-id) %>% mutate(sr = map(data, summarize_sampling_rate)) %>%
dplyr::select(id, sr) %>% unnest)
#' Time intervals range from every 2 to 15 minutes on average, depending
#' on the individual.  Lets add on the time difference to each obs.
trk<-trk %>% group_by(id) %>% mutate(dt_ = t_ - lag(t_, default = NA))
#' THIS LOOP PRODUCES THE ERROR
ssfdat<-NULL
temptrk<-with(trk, track(x=x_, y=y_, t=t_, id=id))
uid<-unique(trk$id) # individual identifiers
luid<-length(uid) # number of unique individuals
for(i in 1:luid){
# Subset individuals & regularize track
temp<-temptrk%>% filter(id==uid[i]) %>%
track_resample(rate=minutes(round(timestats$median[i])),
tolerance=minutes(max(10,round(timestats$median[i]/5))))
# Get rid of any bursts without at least 2 points
temp<-filter_min_n_burst(temp, 2)
# burst steps
stepstemp<-steps_by_burst(temp)
# create random steps using fitted gamma and von mises distributions and append
rnd_stps <- stepstemp %>%  random_steps(n = 15)
# append id
rnd_stps<-rnd_stps%>%mutate(id=uid[i])
# append new data to data from other individuals
ssfdat<-rbind(rnd_stps, ssfdat)
}
ssfdat<-as_tibble(ssfdat)
ssfdat
install.packages("amt")
install.packages("amt")
#' Load libraries
library(knitr)
library(lubridate)
library(raster)
library(move)
library(amt)
library(ggmap)
library(tibble)
library(dplyr)
#' Create a login object for a user account at movebank.org
loginStored <- movebankLogin(username="MovebankWorkshop", password="genericuserforthisexercise")
#' Get overview information about a Movebank study. Be sure to check the citation and license terms if not using your own data.
getMovebankStudy(study="Martes pennanti LaPoint New York", login=loginStored) # see study-level info
#' Load data from a study in Movebank and create a MoveStack object. For more details and options see https://cran.r-project.org/web/packages/move/index.html.
fisher.move <- getMovebankData(study="Martes pennanti LaPoint New York", login=loginStored)
head(fisher.move)
#' Create a data frame from the MoveStack object
fisher.dat <- as(fisher.move, "data.frame")
#' ### Data cleaning
ind<-complete.cases(fisher.dat[,c("location_lat", "location_long", "timestamp")])
fisher.dat<-fisher.dat[ind==TRUE,]
#' Make timestamp a date/time variable
fisher.dat$timestamp<-as.POSIXct(fisher.dat$timestamp, format="%Y-%m-%d %H:%M:%OS", tz="UTC")
#' ## Creating a track in amt
trk <- mk_track(fisher.dat, .x=location_long, .y=location_lat, .t=timestamp, id = local_identifier,
crs = CRS("+init=epsg:4326"))
# Now it is easy to calculate day/night with either movement track
trk <- trk %>% time_of_day()
#' Now, we can transform back to geographic coordinates
trk <- transform_coords(trk, CRS("+init=epsg:32618"))
trk.class<-class(trk)
nesttrk<-trk%>%nest(-id)
trk<-trk %>% nest(-id) %>%
mutate(dir_abs = map(data, direction_abs,full_circle=TRUE, zero="N"),
dir_rel = map(data, direction_rel),
sl = map(data, step_lengths),
nsd_=map(data, nsd))%>%unnest()
trk<-trk%>%
mutate(
week=week(t_),
month = month(t_, label=TRUE),
year=year(t_),
hour = hour(t_)
)
class(trk)<-trk.class
#' ## SSF prep
(timestats<-trk %>% nest(-id) %>% mutate(sr = map(data, summarize_sampling_rate)) %>%
dplyr::select(id, sr) %>% unnest)
#' Time intervals range from every 2 to 15 minutes on average, depending
#' on the individual.  Lets add on the time difference to each obs.
trk<-trk %>% group_by(id) %>% mutate(dt_ = t_ - lag(t_, default = NA))
#' THIS LOOP PRODUCES THE ERROR
ssfdat<-NULL
temptrk<-with(trk, track(x=x_, y=y_, t=t_, id=id))
uid<-unique(trk$id) # individual identifiers
luid<-length(uid) # number of unique individuals
for(i in 1:luid){
# Subset individuals & regularize track
temp<-temptrk%>% filter(id==uid[i]) %>%
track_resample(rate=minutes(round(timestats$median[i])),
tolerance=minutes(max(10,round(timestats$median[i]/5))))
# Get rid of any bursts without at least 2 points
temp<-filter_min_n_burst(temp, 2)
# burst steps
stepstemp<-steps_by_burst(temp)
# create random steps using fitted gamma and von mises distributions and append
rnd_stps <- stepstemp %>%  random_steps(n = 15)
# append id
rnd_stps<-rnd_stps%>%mutate(id=uid[i])
# append new data to data from other individuals
ssfdat<-rbind(rnd_stps, ssfdat)
}
ssfdat<-as_tibble(ssfdat)
ssfdat
