#'  and individual identifier).
ind2<-swazi_data %>% dplyr::select(time, long, lat, id) %>%
duplicated
sum(ind2)
# remove them
swazi_data$dups <- ind2
swazi_data <- filter(swazi_data,dups=="FALSE")
swazi_data
# set the time column
levels(factor(swazi_data$id))
# can look at an individual level with
(filter(swazi_data,id=="ID1"))
# all of the data is in the format of day-month-year
swazi_data$New_time<-parse_date_time(x=swazi_data$time,c("%d/%m/%Y %H:%M"))
# keep only the new time data
swazi_data <- select(swazi_data, New_time,long,lat,id,species,study)
swazi_data <- rename(swazi_data, time = New_time)
swazi_data
#' filter extreme data based on a speed threshold
#' based on vmax which is km/hr
#' time needs to be labelled DateTime for these functions to work
names(swazi_data)[names(swazi_data) == 'time'] <- 'DateTime'
SDLfilterData<-ddfilter.speed(data.frame(swazi_data), vmax = 70, method = 1)
length(SDLfilterData$DateTime)
#' rename everything as before
swazi_data <- SDLfilterData
names(swazi_data)[names(swazi_data) == 'DateTime'] <- 'time'
#' Compare home range analysis from amt package with adehabitatHR
#' Load in the data from 1_load_data.R
#' Check with the Swaziland data
#'
# Swaziland Vulture Tracking Dataset
library(lubridate)
library(SDLfilter)
library(amt)
library(sp)
library(adehabitatHR)
# swazi
# select swazi data which is the data we tracked in Swaziland
swazi_data <- filter(mydata, study == "swazi")
swazi_data
#' Check for duplicated observations (ones with same lat, long, timestamp,
#'  and individual identifier).
ind2<-swazi_data %>% dplyr::select(time, long, lat, id) %>%
duplicated
sum(ind2)
# remove them
swazi_data$dups <- ind2
swazi_data <- filter(swazi_data,dups=="FALSE")
swazi_data
# set the time column
levels(factor(swazi_data$id))
# can look at an individual level with
(filter(swazi_data,id=="ID1"))
# all of the data is in the format of day-month-year
swazi_data$New_time<-parse_date_time(x=swazi_data$time,c("%d/%m/%Y %H:%M"))
# keep only the new time data
swazi_data <- dplyr::select(swazi_data, New_time,long,lat,id,species,study)
swazi_data <- rename(swazi_data, time = New_time)
swazi_data
#' filter extreme data based on a speed threshold
#' based on vmax which is km/hr
#' time needs to be labelled DateTime for these functions to work
names(swazi_data)[names(swazi_data) == 'time'] <- 'DateTime'
SDLfilterData<-ddfilter.speed(data.frame(swazi_data), vmax = 70, method = 1)
length(SDLfilterData$DateTime)
#' rename everything as before
swazi_data <- SDLfilterData
names(swazi_data)[names(swazi_data) == 'DateTime'] <- 'time'
xyt<-subset(swazi_data, select = c(long,lat))
#' Pulling off just the bird IDs:
id<-subset(swazi_data, select = id)
id
#' Creating a SpatialPointsDataFrame for the package adihabitatHR
locs1<-id
coordinates(locs1)<-xyt
class(locs1)
#' plotting the point data:
plot(locs1, col=as.data.frame(locs1)[,1]) # specifies unique color for each bird
locs1
swazi_data
head(swazi_data)
#' Prepare the data for adehabitatHR
#' Pulling off just the X and Y data:
xy <- SpatialPoints(na.omit(ld(swazi_data)[,2:1]))
#' Prepare the data for adehabitatHR
#' Pulling off just the X and Y data:
#' Note below the code uses the original adehabitat package to run home range
loc <- swazi_data[, c("long", "lat")]
#' Estimation of UD for each animal separately
id <- panther[, "id"]
loc
#' Estimation of UD for each animal separately
id <- swazi_data[, "id"]
id
udbis <- kernelUD(loc, id, h = "href")
coordinates(loc)
loc <- coordinates(loc)
class(loc)
#' Prepare the data for adehabitatHR
#' Pulling off just the X and Y data:
coordinates(swazi_data) <- c("long", "lat")
proj4string(track) <- CRS("+init=epsg:4326")
library(rgdal)
proj4string(track) <- CRS("+init=epsg:4326")
?proj4string
library(raster)
proj4string(track) <- CRS("+init=epsg:4326")
proj4string(swazi_data) <- CRS("+init=epsg:4326")
swazi_data
track <- spTransform(track, CRS("+proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"))
swazi_data <- spTransform(swazi_data, CRS("+proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"))
summary(swazi_data)
#' Compare home range analysis from amt package with adehabitatHR
#' Load in the data from 1_load_data.R
#' Check with the Swaziland data
#'
# Swaziland Vulture Tracking Dataset
library(lubridate)
library(SDLfilter)
library(amt)
library(sp)
library(adehabitatHR)
library(rgdal)
library(raster)
# swazi
# select swazi data which is the data we tracked in Swaziland
swazi_data <- filter(mydata, study == "swazi")
swazi_data
#' Check for duplicated observations (ones with same lat, long, timestamp,
#'  and individual identifier).
ind2<-swazi_data %>% dplyr::select(time, long, lat, id) %>%
duplicated
sum(ind2)
# remove them
swazi_data$dups <- ind2
swazi_data <- filter(swazi_data,dups=="FALSE")
swazi_data
# set the time column
levels(factor(swazi_data$id))
# can look at an individual level with
(filter(swazi_data,id=="ID1"))
# all of the data is in the format of day-month-year
swazi_data$New_time<-parse_date_time(x=swazi_data$time,c("%d/%m/%Y %H:%M"))
# keep only the new time data
swazi_data <- dplyr::select(swazi_data, New_time,long,lat,id,species,study)
swazi_data <- rename(swazi_data, time = New_time)
swazi_data
#' filter extreme data based on a speed threshold
#' based on vmax which is km/hr
#' time needs to be labelled DateTime for these functions to work
names(swazi_data)[names(swazi_data) == 'time'] <- 'DateTime'
SDLfilterData<-ddfilter.speed(data.frame(swazi_data), vmax = 70, method = 1)
length(SDLfilterData$DateTime)
#' rename everything as before
swazi_data <- SDLfilterData
names(swazi_data)[names(swazi_data) == 'DateTime'] <- 'time'
swazi_data <- dplyr::select(swazi_data, id,long,lat)
swazi_data
#' Prepare the data for adehabitatHR
#' Pulling off just the X and Y data:
coordinates(swazi_data) <- c("long", "lat")
proj4string(swazi_data) <- CRS("+init=epsg:4326")
swazi_data <- spTransform(swazi_data, CRS("+proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"))
summary(swazi_data)
#' Compare home range analysis from amt package with adehabitatHR
#' Load in the data from 1_load_data.R
#' Check with the Swaziland data
#'
# Swaziland Vulture Tracking Dataset
library(lubridate)
library(SDLfilter)
library(amt)
library(sp)
library(adehabitatHR)
library(rgdal)
library(raster)
# swazi
# select swazi data which is the data we tracked in Swaziland
swazi_data <- filter(mydata, study == "swazi")
swazi_data
#' Check for duplicated observations (ones with same lat, long, timestamp,
#'  and individual identifier).
ind2<-swazi_data %>% dplyr::select(time, long, lat, id) %>%
duplicated
sum(ind2)
# remove them
swazi_data$dups <- ind2
swazi_data <- filter(swazi_data,dups=="FALSE")
swazi_data
# set the time column
levels(factor(swazi_data$id))
# can look at an individual level with
(filter(swazi_data,id=="ID1"))
# all of the data is in the format of day-month-year
swazi_data$New_time<-parse_date_time(x=swazi_data$time,c("%d/%m/%Y %H:%M"))
# keep only the new time data
swazi_data <- dplyr::select(swazi_data, New_time,long,lat,id,species,study)
swazi_data <- rename(swazi_data, time = New_time)
#' filter extreme data based on a speed threshold
#' based on vmax which is km/hr
#' time needs to be labelled DateTime for these functions to work
names(swazi_data)[names(swazi_data) == 'time'] <- 'DateTime'
SDLfilterData<-ddfilter.speed(data.frame(swazi_data), vmax = 70, method = 1)
length(SDLfilterData$DateTime)
#' rename everything as before
swazi_data <- SDLfilterData
names(swazi_data)[names(swazi_data) == 'DateTime'] <- 'time'
swazi_data <- dplyr::select(swazi_data, id,long,lat)
#' Prepare the data for adehabitatHR
#' Pulling off just the X and Y data:
#There are three main arguments we are specifying:
#The Coordinates (as longitude and latitude),
#the data that will go in the table (zebra.spdf), and the projection information
swazi.spdf <- SpatialPointsDataFrame(coords=as.data.frame(cbind(swazi_data$long,
swazi_data$lat)), data=swazi_data, proj4string =
CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"))
swazi.spdf <- spTransform(swazi.spdf,
CRS("+proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"))
#' You can plot the points as you would any other Spatial object
#' it might take a minute as there are a lot of points
plot(swazi.spdf)
swazi_data[, 1]
swazi.mcp <- mcp(swazi_data[, 1], percent = 95,
unin = "m", unout = "km2")
swazi_data
swazi.spdf[, 1]
# First: 100% MCP
swazi.mcp <- mcp(swazi.spdf[, 1], percent = 95,
unin = "m", unout = "km2")
swazi.mcp
swazi.mcp
ggplot(swazi.mcp)
ggplot(swazi.mcp) +geom_area()
class(swazi.mcp)
plot(swazi.mcp, col = c(1:2))
plot(swazi.mcp, col = c(1:2), axes = TRUE)
#' Kernel Density Estimate
swazi.Khref <- kernelUD(swazi.spdf[,1], h = "href")
#' # You can plot the KDE for each individual separately:
image(swazi.Khref)
#' Compare home range analysis from amt package with adehabitatHR
#' Load in the data from 1_load_data.R
#' Check with the Swaziland data
#' https://mltconsecol.github.io/TU_LandscapeAnalysis_Documents/Assignments_web/Assignment09_AnimalMovement.pdf
#' Swaziland Vulture Tracking Dataset
library(lubridate)
library(SDLfilter)
library(amt)
library(sp)
library(adehabitatHR)
library(rgdal)
library(raster)
# swazi
# select swazi data which is the data we tracked in Swaziland
swazi_data <- filter(mydata, study == "swazi")
swazi_data
#' Check for duplicated observations (ones with same lat, long, timestamp,
#'  and individual identifier).
ind2 <- swazi_data %>% dplyr::select(time, long, lat, id) %>%
duplicated
sum(ind2)
# remove them
swazi_data$dups <- ind2
swazi_data <- filter(swazi_data, dups == "FALSE")
swazi_data
# set the time column
levels(factor(swazi_data$id))
# can look at an individual level with
(filter(swazi_data, id == "ID1"))
# all of the data is in the format of day-month-year
swazi_data$New_time <-
parse_date_time(x = swazi_data$time, c("%d/%m/%Y %H:%M"))
# keep only the new time data
swazi_data <-
dplyr::select(swazi_data, New_time, long, lat, id, species, study)
swazi_data <- rename(swazi_data, time = New_time)
#' filter extreme data based on a speed threshold
#' based on vmax which is km/hr
#' time needs to be labelled DateTime for these functions to work
names(swazi_data)[names(swazi_data) == 'time'] <- 'DateTime'
SDLfilterData <-
ddfilter.speed(data.frame(swazi_data), vmax = 70, method = 1)
length(SDLfilterData$DateTime)
#' rename everything as before
swazi_data <- SDLfilterData
names(swazi_data)[names(swazi_data) == 'DateTime'] <- 'time'
swazi_data <- dplyr::select(swazi_data, id, long, lat, time)
#' Prepare the data for adehabitatHR
#' There are three main arguments we are specifying:
#' The Coordinates (as longitude and latitude),
#' the data that will go in the table (swazi.spdf), and the projection information
swazi.spdf <-
SpatialPointsDataFrame(
coords = as.data.frame(cbind(swazi_data$long,
swazi_data$lat)),
data = swazi_data,
proj4string =
CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
)
#' The data are in a degree-based coordinate system. One last thing we’ll have to do is transform them to
#' a meter-based coordinate system, for purposes of area calculations and such with home ranges
swazi.spdf <- spTransform(
swazi.spdf,
CRS(
"+proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
)
)
#' You can plot the points as you would any other Spatial object
#' it might take a minute as there are a lot of points
plot(swazi.spdf)
# First: 95% MCP
swazi.mcp <- mcp(swazi.spdf[, 1],
percent = 95,
unin = "m",
unout = "km2")
swazi.mcp
plot(swazi.mcp, col = c(1:2), axes = TRUE)
#' Kernel Density Estimate
swazi.Khref <- kernelUD(swazi.spdf[, 1], h = "href")
#' # You can plot the KDE for each individual separately:
image(swazi.Khref)
#' Considering Paths of Animal Movement and Dealing with Temporal Autocorrelation (Brownian Bridge Movement Model)
swazi.traj <- as.ltraj(coordinates(swazi.spdf), date=swazi.spdf$time
,id=swazi.spdf$id)
# View what this looks like
swazi.traj
#' You can plot the trajectory for each individual - the numbers correspond to the ID in the zeb.traj object above
plot(swazi.traj[1])
plot(swazi.traj[2])
likSwazi <- liker(swazi.traj, sig2 = 100, rangesig1 = c(1, 50))
#' We can now model the home ranges using the Brownian Bridge Movement Model, using the respective sig1
#' values for each individual. The function for this is ‘kernelbb’. We will enter the sig1 values as a list after the
#' argument ‘sig1’:
#' This works on all individuals at once
swazi.bb <- kernelbb(swazi.traj, sig1 = c(18.2162, 22.6306),
sig2 = 100)
# Again, you can plot the modeled home range as with the Kernel Density
# Estimates.
image(swazi.bb)
zebBB.95@data
#' As with the prevous home range estimators, you can also extract the area of the specified home range for the
#' Brownian Bridge Movement Model based at the desired level (we will use the 95% level again):
swazi.bb@data
#' Get boundaries of 95% probability surface for a home range estimate
swaziBB.95 <- getverticeshr(swazi.bb, 95, unout = "km2")
#' As with the prevous home range estimators, you can also extract the area of the specified home range for the
#' Brownian Bridge Movement Model based at the desired level (we will use the 95% level again):
swaziBB.95@data
# And you can make it into it's own raster object, to write it to an
# external file, etc.
ID1 <- (raster(as(swazi.bb$ID1, "SpatialPixelsDataFrame")))
# Plot the individual raster; you might need to close out of the previous
# plot for this to appear appropriately
plot(ID1)
# Plot the individual raster; you might need to close out of the previous
# plot for this to appear appropriately
plot(ID1)
# Extract the points for only individual Z3743
ID1 <- swazi.spdf[swazi.spdf$individual.local.identifier == "ID1", ]
# Plot those points on the raster
plot(ID1, add = TRUE, cex = 0.01)
#' Get boundaries of 95% probability surface for a home range estimate
swaziBB.95 <- getverticeshr(swazi.bb, 95, unout = "km2")
# Plot the bounds for the first individual (ID1)
plot(swaziBB.95[1, ], border = "red", lwd = 2, add = TRUE)
ID1 <- (raster(as(swazi.bb$ID1, "SpatialPixelsDataFrame")))
# Plot the individual raster; you might need to close out of the previous
# plot for this to appear appropriately
plot(ID1)
# Extract the points for only individual Z3743
ID1 <- swazi.spdf[swazi.spdf$individual.local.identifier == "ID1", ]
# Plot those points on the raster
plot(ID1, add = TRUE, cex = 0.01)
#' Get boundaries of 95% probability surface for a home range estimate
swaziBB.95 <- getverticeshr(swazi.bb, 95, unout = "km2")
# Plot the bounds for the first individual (ID1)
plot(swaziBB.95[1, ], border = "red", lwd = 2, add = TRUE)
swaziBB.95[1, ]
#' As with the prevous home range estimators, you can also extract the area of the specified home range for the
#' Brownian Bridge Movement Model based at the desired level (we will use the 95% level again):
swaziBB.95@data
swaziBB.95[1, ]
swaziBB.95[2, ]
# And you can make it into it's own raster object, to write it to an
# external file, etc.
ID2 <- (raster(as(swazi.bb$ID1, "SpatialPixelsDataFrame")))
# Plot the individual raster; you might need to close out of the previous
# plot for this to appear appropriately
plot(ID2)
# Extract the points for only individual ID2
ID2 <- swazi.spdf[swazi.spdf$individual.local.identifier == "ID2", ]
# Plot those points on the raster
plot(ID2, add = TRUE, cex = 0.01)
#' Get boundaries of 95% probability surface for a home range estimate
swaziBB.95 <- getverticeshr(swazi.bb, 95, unout = "km2")
# Plot the bounds for the first individual (ID2)
plot(swaziBB.95[2, ], border = "red", lwd = 2, add = TRUE)
ID2 <- (raster(as(swazi.bb$ID1, "SpatialPixelsDataFrame")))
# Plot the individual raster; you might need to close out of the previous
# plot for this to appear appropriately
plot(ID2)
# Extract the points for only individual ID2
ID2 <- swazi.spdf[swazi.spdf$individual.local.identifier == "ID2", ]
# Plot those points on the raster
plot(ID2, add = TRUE, cex = 0.01)
#' Get boundaries of 95% probability surface for a home range estimate
swaziBB.95 <- getverticeshr(swazi.bb, 95, unout = "km2")
# Plot the bounds for the first individual (ID2)
plot(swaziBB.95[2, ], border = "red", lwd = 2, add = TRUE)
ID2 <- (raster(as(swazi.bb$ID1, "SpatialPixelsDataFrame")))
# Plot the individual raster; you might need to close out of the previous
# plot for this to appear appropriately
plot(ID2)
# Extract the points for only individual ID2
ID2 <- swazi.spdf[swazi.spdf$id == "ID2", ]
# Plot those points on the raster
plot(ID2, add = TRUE, cex = 0.01)
#' Get boundaries of 95% probability surface for a home range estimate
swaziBB.95 <- getverticeshr(swazi.bb, 95, unout = "km2")
# Plot the bounds for the first individual (ID2)
plot(swaziBB.95[2, ], border = "red", lwd = 2, add = TRUE)
swazi.spdf
?coordinates
swazi.Khref
#' Kernel Density Estimate
swazi.Khref <- kernelUD(swazi.spdf[, 1], h = "href")
#' # You can plot the KDE for each individual separately:
image(swazi.Khref)
str(swazi.Khref)
swazi.Khref[1]
swazi.Khref[,1]
swazi.Khref[1,]
#' The values of the smoothing parameters are stored in the slot "h" of each
#' element of the list. For example, to get the h-value for the first animal:
swazi.Khref[[1]]@h
swazi.Khref[[2]]@h
swazi.Khref[[1]]
#' Alternatively, we could have set the argument h equal to "LSCV". The LSCV
#' algorithm searches for the optimum value of h in the interval specified by the
#' parameter hlim.
kudl <- kernelUD(swazi.spdf[, 1], h="LSCV")
#' Alternatively, we could have set the argument h equal to "LSCV". The LSCV
#' algorithm searches for the optimum value of h in the interval specified by the
#' parameter hlim.
kudl <- kernelUD(swazi.spdf[, 1], h="LSCV")
#' Alternatively, we could have set the argument h equal to "LSCV". The LSCV
#' algorithm searches for the optimum value of h in the interval specified by the
#' parameter hlim.
kudl <- kernelUD(swazi.spdf[, 1], h="LSCV")
#' calculate the home range size
ii <- kernel.area(swazi.Khref, percent=seq(50, 95, by=5))
ii
swazi.mcp
13583436 - 128186.911
#' # You can plot the KDE for each individual separately:
image(swazi.Khref)
2938839.1 / 1000000
swazi.Khref
#' Kernel Density Estimate
swazi.Khref <- kernelUD(swazi.spdf[, 1], h = "href")
#' # You can plot the KDE for each individual separately:
image(swazi.Khref)
#' The values of the smoothing parameters are stored in the slot "h" of each
#' element of the list.
swazi.Khref[[1]]@h
swazi.Khref[[2]]@h
#' calculate the home range size
ii <- kernel.area(swazi.Khref, percent=seq(50, 95, by=5))
ii # values don't match amt
?kernelUD
swazi.Khref <- kernelUD(swazi.spdf[, 1], h = 5000)
#' # You can plot the KDE for each individual separately:
image(swazi.Khref)
#' The values of the smoothing parameters are stored in the slot "h" of each
#' element of the list.
swazi.Khref[[1]]@h
swazi.Khref[[2]]@h
#' calculate the home range size
ii <- kernel.area(swazi.Khref, percent=seq(50, 95, by=5))
ii # values don't match amt
swazi.Khref <- kernelUD(swazi.spdf[, 1], h = 10000)
#' # You can plot the KDE for each individual separately:
image(swazi.Khref)
#' The values of the smoothing parameters are stored in the slot "h" of each
#' element of the list.
swazi.Khref[[1]]@h
swazi.Khref[[2]]@h
#' calculate the home range size
ii <- kernel.area(swazi.Khref, percent=seq(50, 95, by=5))
ii # values don't match amt
?hr_kde
#' measure the size of the home range using this kernel estimator
swazi.Khref.poly <- getverticeshr(swazi.Khref, percent = 95)
print(swazi.Khref.poly)  # returns the area of each polygon
#' Kernel Density Estimate
swazi.Khref <- kernelUD(swazi.spdf[, 1], h = "href")
#' # You can plot the KDE for each individual separately:
image(swazi.Khref)
#' The values of the smoothing parameters are stored in the slot "h" of each
#' element of the list.
swazi.Khref[[1]]@h
swazi.Khref[[2]]@h
#' measure the size of the home range using this kernel estimator
swazi.Khref.poly <- getverticeshr(swazi.Khref, percent = 95)
print(swazi.Khref.poly)  # returns the area of each polygon
# Plot the bounds for the first individual (ID2)
plot(swaziBB.95[2, ], border = "red", lwd = 2, add = TRUE)
#' As with the prevous home range estimators, you can also extract the area of the specified home range for the
#' Brownian Bridge Movement Model based at the desired level (we will use the 95% level again):
swaziBB.95@data
?getverticeshr
