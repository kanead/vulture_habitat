geom_smooth()+ facet_wrap(~id, scales="free")
#' Same for KDE
kde.week<-trk %>% nest(-id,-year,  -month, -week) %>%
mutate(kdearea = map(data, ~hr_kde(., levels=c(0.95)) %>% hr_area)) %>%
select(id, year, month, week,  kdearea) %>% unnest()
#+fig.height=12, fig.width=12, warning=FALSE, message=FALSE
ggplot(kde.week, aes(x = week, y = kdearea, colour=as.factor(year))) + geom_point()+
geom_smooth()+ facet_wrap(~id, scales="free")
# burst steps
stepstemp<-steps_by_burst(temp)
# create random steps using fitted gamma and von mises distributions and append
rnd_stps <- stepstemp %>%  random_steps(n = 15)
# append id
rnd_stps<-rnd_stps%>%mutate(id=uid[i])
# append new data to data from other individuals
ssfdat<-rbind(rnd_stps, ssfdat)
}
#+warning=FALSE
ssfdat<-NULL
temptrk<-with(trk, track(x=x_, y=y_, t=t_, id=id))
uid<-unique(trk$id) # individual identifiers
luid<-length(uid) # number of unique individuals
for(i in 1:luid){
# Subset individuals & regularize track
temp<-temptrk%>% filter(id==uid[i]) %>%
track_resample(rate=hours(round(timestats$median[i])),
tolerance=minutes(10))
#' Get rid of any bursts without at least 2 points
temp<-filter_min_n_burst(temp, 2)
#' convert back into an amt track
trk <- mk_track(temp, .x=x_, .y=y_, .t=t_, id = id,
crs = CRS("+init=epsg:4326"))
#' ### Space use (MCP or KDE) by week, month, and year
#'
#' Note:  this code will only work for your critters if you
#' have multiple observations for each combination of
#' (month, year).  If you don't have many observations, you could
#' try:  nest(-id, -year) and unnest(id,year)
home_range <- trk %>% group_by(id)
mcps.week<-trk %>% nest(-id) %>%
mutate(mcparea = map(data, ~hr_mcp(., levels = c(0.95)) %>% hr_area)) %>%
select(id,mcparea) %>% unnest()
#+fig.height=12, fig.width=12, warning=FALSE, message=FALSE
ggplot(mcps.week, aes(x = week, y = area, colour=as.factor(year))) + geom_point()+
geom_smooth()+ facet_wrap(~id, scales="free")
#' Same for KDE
kde.week<-trk %>% nest(-id,-year,  -month, -week) %>%
mutate(kdearea = map(data, ~hr_kde(., levels=c(0.95)) %>% hr_area)) %>%
select(id, year, month, week,  kdearea) %>% unnest()
#+fig.height=12, fig.width=12, warning=FALSE, message=FALSE
ggplot(kde.week, aes(x = week, y = kdearea, colour=as.factor(year))) + geom_point()+
geom_smooth()+ facet_wrap(~id, scales="free")
# burst steps
stepstemp<-steps_by_burst(temp)
# create random steps using fitted gamma and von mises distributions and append
rnd_stps <- stepstemp %>%  random_steps(n = 15)
# append id
rnd_stps<-rnd_stps%>%mutate(id=uid[i])
# append new data to data from other individuals
ssfdat<-rbind(rnd_stps, ssfdat)
}
library(lubridate)
library(SDLfilter)
library(amt)
library(sp)
# select ck_tanz data which is Corinne's data from everything
ck_tanz_data <- filter(mydata, study == "ck_tanz")
ck_tanz_data
sum(ind2)
#' Check for duplicated observations (ones with same lat, long, timestamp,
#'  and individual identifier).
ind2<-ck_tanz_data %>% select(long, lat, id) %>%
duplicated
# remove them
ck_tanz_data$dups <- ind2
ck_tanz_data <- filter(ck_tanz_data,dups=="FALSE")
ck_tanz_data
# can look at an individual level with
(filter(ck_tanz_data,id=="33021"))
# set the time column
levels(factor(ck_tanz_data$id))
# all of the data is in the format of day-month-year
ck_tanz_data$New_time<-parse_date_time(x=ck_tanz_data$time,c("%d/%m/%Y %H:%M"))
# keep only the new time data
ck_tanz_data <- select(ck_tanz_data, New_time,long,lat,id,species,study)
ck_tanz_data <- rename(ck_tanz_data, time = New_time)
# check the minimum time and the maximum time
min_time <- ck_tanz_data %>% group_by(id) %>% slice(which.min(time))
data.frame(min_time)
max_time <- ck_tanz_data %>% group_by(id) %>% slice(which.max(time))
data.frame(max_time)
ck_tanz_data
#' filter extreme data based on a speed threshold
#' based on vmax which is km/hr
#' time needs to be labelled DateTime for these functions to work
names(ck_tanz_data)[names(ck_tanz_data) == 'time'] <- 'DateTime'
SDLfilterData<-ddfilter.speed(data.frame(ck_tanz_data), vmax = 60, method = 1)
length(SDLfilterData$DateTime)
#' rename everything as before
ck_tanz_data <- SDLfilterData
names(ck_tanz_data)[names(ck_tanz_data) == 'DateTime'] <- 'time'
# try the amt package
trk <- mk_track(ck_tanz_data, .x=long, .y=lat, .t=time, id = id, species=species,
crs = CRS("+init=epsg:4326"))
# Now it is easy to calculate day/night with either movement track
trk <- trk %>% time_of_day()
#' Save the class here (and apply it later after adding columns to the
#' object)
trk.class<-class(trk)
# nest by id
nesttrk<-trk%>%nest(-id)
nesttrk
#' We can add a columns to each nested column of data using purrr::map
trk<-trk %>% nest(-id) %>%
mutate(dir_abs = map(data, direction_abs,full_circle=TRUE, zero="N"),
dir_rel = map(data, direction_rel),
sl = map(data, step_lengths),
nsd_=map(data, nsd))%>%unnest()
#' Now, calculate month, year, hour, week of each observation and append these to the dataset
#' Unlike the movement charactersitics, these calculations can be done all at once,
#' since they do not utilize successive observations (like step lengths and turn angles do).
trk<-trk%>%
mutate(
week=week(t_),
month = month(t_, label=TRUE),
year=year(t_),
hour = hour(t_)
)
#' Now, we need to again tell R that this is a track (rather
#' than just a data frame)
class(trk)
class(trk)<-trk.class
#' Lets take a look at what we created
trk <- trk %>% group_by(id)
trk
#' some data points look a little off
#' we can identify them to investiage further and remove them
#' if needs be
filter(trk,id=="163115" & nsd_ < 15)
trk<- trk  %>%
filter(!((id=="163115" & nsd_ > 15)))
#' ## SSF prep
#'
#' SSFs assume that data have been collected at regular time intervals.
#' We can use the track_resample function to regularize the trajectory so that
#' all points are located within some tolerence of each other in time. To figure
#' out a meaningful tolerance range, we should calculate time differences between
#' locations & look at as a function of individual.
(timestats<-trk %>% nest(-id) %>% mutate(sr = map(data, summarize_sampling_rate)) %>%
dplyr::select(id, sr) %>% unnest)
#' add species names to the time intervals
timestats <- timestats %>%
left_join(trk %>%
distinct(id, species), by = 'id')
#' add the study name
timestats$study <- "ck_tanz"
head(timestats)
#' make sure it matches up
filter(trk,id=="33021") # hv
filter(trk,id=="33017") # wb
filter(trk,id=="163119") # wh
#' let's select just the AWBVs
trk <- filter(trk,species=="wb")
trk
# need to run timestats again for the subsetted dataframe so that the IDs match up below
(timestats<-trk %>% nest(-id) %>% mutate(sr = map(data, summarize_sampling_rate)) %>%
dplyr::select(id, sr) %>% unnest)
#' Time intervals range depending on the individual.
#' Lets add on the time difference to each obs.
trk<-trk %>% group_by(id) %>% mutate(dt_ = t_ - lag(t_, default = NA))
#+warning=FALSE
ssfdat<-NULL
temptrk<-with(trk, track(x=x_, y=y_, t=t_, id=id))
uid<-unique(trk$id) # individual identifiers
luid<-length(uid) # number of unique individuals
for(i in 1:luid){
# Subset individuals & regularize track
temp<-temptrk%>% filter(id==uid[i]) %>%
track_resample(rate=hours(round(timestats$median[i])),
tolerance=minutes(10)) #' tolerance is 10 minutes
# Get rid of any bursts without at least 2 points
temp<-filter_min_n_burst(temp, 2)
# burst steps
stepstemp<-steps_by_burst(temp)
# create random steps using fitted gamma and von mises distributions and append
rnd_stps <- stepstemp %>%  random_steps(n = 15)
# append id
rnd_stps<-rnd_stps%>%mutate(id=uid[i])
# append new data to data from other individuals
ssfdat<-rbind(rnd_stps, ssfdat)
}
ssfdat<-as_tibble(ssfdat)
ssfdat
head(trk)
filter(trk, id == "33017")
#' convert our regularised data back into a trk type data frame
home_range_data <- ssfdat %>% filter(case_=="TRUE") %>% select(x1_, y1_, t1_, id)
home_range_data
#' convert our regularised data back into a trk type data frame
home_range_data <- ssfdat %>% filter(case_=="TRUE") %>% select(x1_, y1_, t1_, id) %>% group_by(id)
home_range_data
home_range_trk <- mk_track(home_range_data, .x=x1_, .y=y1_, .t=t1_, id = id,
crs = CRS("+init=epsg:4326"))
home_range_trk
mcps <-home_range_trk %>% nest(-id) %>%
mutate(mcparea = map(data, ~hr_mcp(., levels = c(0.95)) %>% hr_area)) %>%
select(id, mcparea) %>% unnest()
mcps
#+fig.height=12, fig.width=12, warning=FALSE, message=FALSE
ggplot(mcps.week, aes(x = id, y = area, colour=as.factor(year))) + geom_point()+
geom_smooth()+ facet_wrap(~id, scales="free")
#+fig.height=12, fig.width=12, warning=FALSE, message=FALSE
ggplot(mcps.week, aes(x = id, y = area)) + geom_point()+
geom_smooth()+ facet_wrap(~id, scales="free")
#+fig.height=12, fig.width=12, warning=FALSE, message=FALSE
ggplot(mcps, aes(x = id, y = area)) + geom_point()+
geom_smooth()+ facet_wrap(~id, scales="free")
#+fig.height=12, fig.width=12, warning=FALSE, message=FALSE
ggplot(mcps, aes(x = id, y = area)) + geom_point()+
geom_smooth()
#' Same for KDE
kde <-home_range_trk %>% nest(-id) %>%
mutate(kdearea = map(data, ~hr_kde(., levels=c(0.95)) %>% hr_area)) %>%
select(id, kdearea) %>% unnest()
#+fig.height=12, fig.width=12, warning=FALSE, message=FALSE
ggplot(kde, aes(x = id, y = kdearea)) + geom_point()+
geom_smooth()
#' plot it again
ggplot(trk, aes(x = t_, y=nsd_)) + geom_point()+
facet_wrap(~id, scales="free")
#' map the data
library(leaflet)
head(home_range_data)
leaflet() %>% addTiles() %>%
addCircleMarkers(data = home_range_data,
lat = ~y1_, lng = ~x1_,
color = "blue")
levels(home_range_data$id)
levels(home_range_data$as.factor(id))
#' convert our regularised data back into a trk type data frame
home_range_data <- ssfdat %>% filter(case_=="TRUE") %>% select(x1_, y1_, t1_, id) %>% group_by(id)
home_range_trk <- mk_track(home_range_data, .x=x1_, .y=y1_, .t=t1_, id = id,
crs = CRS("+init=epsg:4326"))
home_range_data
#' map the data
library(leaflet)
leaflet() %>% addTiles() %>%
addCircleMarkers(data = filter(home_range_data, id == "163113"),
lat = ~y1_, lng = ~x1_,
color = "blue")
leaflet() %>% addTiles() %>%
addCircleMarkers(data = filter(home_range_data, id == "33017"),
lat = ~y1_, lng = ~x1_,
color = "blue")
levels(home_range_data$id)
home_range_data
groups(home_range_data$id)
levels(as.factor(home_range_data$id))
levels(as.factor(home_range_data$id))
leaflet() %>% addTiles() %>%
addCircleMarkers(data = filter(home_range_data, id == "33010"),
lat = ~y1_, lng = ~x1_,
color = "blue")
leaflet() %>% addTiles() %>%
addCircleMarkers(data = filter(home_range_data, id == "163117"),
lat = ~y1_, lng = ~x1_,
color = "blue")
leaflet() %>% addTiles() %>%
addCircleMarkers(data = filter(home_range_data, id == "163113"),
lat = ~y1_, lng = ~x1_,
color = "blue")
library(lubridate)
library(SDLfilter)
library(sp)
# select swazi data which is the data we tracked in Swaziland
swazi_data <- filter(mydata, study == "swazi")
library(amt)
swazi_data
#' Check for duplicated observations (ones with same lat, long, timestamp,
#'  and individual identifier).
ind2<-swazi_data %>% select(time, long, lat, id) %>%
duplicated
sum(ind2)
# remove them
swazi_data$dups <- ind2
swazi_data <- filter(swazi_data,dups=="FALSE")
swazi_data
# set the time column
levels(factor(swazi_data$id))
# can look at an individual level with
(filter(swazi_data,id=="ID1"))
# all of the data is in the format of day-month-year
swazi_data$New_time<-parse_date_time(x=swazi_data$time,c("%d/%m/%Y %H:%M"))
# keep only the new time data
swazi_data <- select(swazi_data, New_time,long,lat,id,species,study)
swazi_data <- rename(swazi_data, time = New_time)
swazi_data
data.frame(min_time)
max_time <- swazi_data %>% group_by(id) %>% slice(which.max(time))
# check the minimum time and the maximum time
min_time <- swazi_data %>% group_by(id) %>% slice(which.min(time))
data.frame(max_time)
SDLfilterData<-ddfilter.speed(data.frame(swazi_data), vmax = 60, method = 1)
#' filter extreme data based on a speed threshold
#' based on vmax which is km/hr
#' time needs to be labelled DateTime for these functions to work
names(swazi_data)[names(swazi_data) == 'time'] <- 'DateTime'
length(SDLfilterData$DateTime)
#' rename everything as before
swazi_data <- SDLfilterData
names(swazi_data)[names(swazi_data) == 'DateTime'] <- 'time'
#' plot the tracks
ggplot(swazi_data, aes(x = long,
y = lat)) + geom_point() +
facet_wrap(~id, scales = "free")
# try the amt package
trk <- mk_track(swazi_data, .x=long, .y=lat, .t=time, id = id, species=species,
crs = CRS("+init=epsg:4326"))
# Now it is easy to calculate day/night with either movement track
trk <- trk %>% time_of_day()
#' Save the class here (and apply it later after adding columns to the
#' object)
trk.class<-class(trk)
# nest by id
nesttrk<-trk%>%nest(-id)
nesttrk
#' We can add a columns to each nested column of data using purrr::map
trk<-trk %>% nest(-id) %>%
mutate(dir_abs = map(data, direction_abs,full_circle=TRUE, zero="N"),
dir_rel = map(data, direction_rel),
sl = map(data, step_lengths),
nsd_=map(data, nsd))%>%unnest()
#' Now, calculate month, year, hour, week of each observation and append these to the dataset
#' Unlike the movement charactersitics, these calculations can be done all at once,
#' since they do not utilize successive observations (like step lengths and turn angles do).
trk<-trk%>%
mutate(
week=week(t_),
month = month(t_, label=TRUE),
year=year(t_),
hour = hour(t_)
)
# select swazi data which is the data we tracked in Swaziland
swazi_data <- filter(mydata, study == "swazi")
swazi_data
#' Check for duplicated observations (ones with same lat, long, timestamp,
#'  and individual identifier).
ind2<-swazi_data %>% select(time, long, lat, id) %>%
duplicated
sum(ind2)
# remove them
swazi_data$dups <- ind2
swazi_data <- filter(swazi_data,dups=="FALSE")
swazi_data
# set the time column
levels(factor(swazi_data$id))
# can look at an individual level with
(filter(swazi_data,id=="ID1"))
# all of the data is in the format of day-month-year
swazi_data$New_time<-parse_date_time(x=swazi_data$time,c("%d/%m/%Y %H:%M"))
# keep only the new time data
swazi_data <- select(swazi_data, New_time,long,lat,id,species,study)
swazi_data <- rename(swazi_data, time = New_time)
swazi_data
# check the minimum time and the maximum time
min_time <- swazi_data %>% group_by(id) %>% slice(which.min(time))
data.frame(min_time)
max_time <- swazi_data %>% group_by(id) %>% slice(which.max(time))
data.frame(max_time)
#' filter extreme data based on a speed threshold
#' based on vmax which is km/hr
#' time needs to be labelled DateTime for these functions to work
names(swazi_data)[names(swazi_data) == 'time'] <- 'DateTime'
SDLfilterData<-ddfilter.speed(data.frame(swazi_data), vmax = 60, method = 1)
length(SDLfilterData$DateTime)
#' rename everything as before
swazi_data <- SDLfilterData
names(swazi_data)[names(swazi_data) == 'DateTime'] <- 'time'
# try the amt package
trk <- mk_track(swazi_data, .x=long, .y=lat, .t=time, id = id, species=species,
crs = CRS("+init=epsg:4326"))
# Now it is easy to calculate day/night with either movement track
trk <- trk %>% time_of_day()
#' Save the class here (and apply it later after adding columns to the
#' object)
trk.class<-class(trk)
# nest by id
nesttrk<-trk%>%nest(-id)
nesttrk
#' We can add a columns to each nested column of data using purrr::map
trk<-trk %>% nest(-id) %>%
mutate(dir_abs = map(data, direction_abs,full_circle=TRUE, zero="N"),
dir_rel = map(data, direction_rel),
sl = map(data, step_lengths),
nsd_=map(data, nsd))%>%unnest()
#' Now, we need to again tell R that this is a track (rather
#' than just a data frame)
class(trk)
class(trk)<-trk.class
#' Lets take a look at what we created
trk <- trk %>% group_by(id)
trk
#' ## SSF prep
#'
#' SSFs assume that data have been collected at regular time intervals.
#' We can use the track_resample function to regularize the trajectory so that
#' all points are located within some tolerence of each other in time. To figure
#' out a meaningful tolerance range, we should calculate time differences between
#' locations & look at as a function of individual.
(timestats<-trk %>% nest(-id) %>% mutate(sr = map(data, summarize_sampling_rate)) %>%
dplyr::select(id, sr) %>% unnest)
#' add species names to the time intervals
timestats <- timestats %>%
left_join(trk %>%
distinct(id, species), by = 'id')
#' add the study name
timestats$study <- "ck_swazi"
head(timestats)
#' make sure it matches up
filter(trk,id=="ID1") # wb
filter(trk,id=="ID2") # wb
#' let's select just the AWBVs
trk <- filter(trk,species=="wb")
trk
levels(as.factor(trk$species))
# need to run timestats again for the subsetted dataframe so that the IDs match up below
(timestats<-trk %>% nest(-id) %>% mutate(sr = map(data, summarize_sampling_rate)) %>%
dplyr::select(id, sr) %>% unnest)
#' Time intervals range depending on the individual.
#' Lets add on the time difference to each obs.
trk<-trk %>% group_by(id) %>% mutate(dt_ = t_ - lag(t_, default = NA))
trk
#+warning=FALSE
ssfdat<-NULL
temptrk<-with(trk, track(x=x_, y=y_, t=t_, id=id))
#+warning=FALSE
ssfdat<-NULL
temptrk<-with(trk, track(x=x_, y=y_, t=t_, id=id))
uid<-unique(trk$id) # individual identifiers
luid<-length(uid) # number of unique individuals
for(i in 1:luid){
# Subset individuals & regularize track
temp<-temptrk%>% filter(id==uid[i]) %>%
track_resample(rate=hours(round(1)),
tolerance=minutes(10))
# Get rid of any bursts without at least 2 points
temp<-filter_min_n_burst(temp, 2)
# burst steps
stepstemp<-steps_by_burst(temp)
# create random steps using fitted gamma and von mises distributions and append
rnd_stps <- stepstemp %>%  random_steps(n = 15)
# append id
rnd_stps<-rnd_stps%>%mutate(id=uid[i])
# append new data to data from other individuals
ssfdat<-rbind(rnd_stps, ssfdat)
}
ssfdat<-as_tibble(ssfdat)
ssfdat
#' convert our regularised data back into a trk type data frame
home_range_data <- ssfdat %>% filter(case_=="TRUE") %>% select(x1_, y1_, t1_, id) %>% group_by(id)
home_range_trk <- mk_track(home_range_data, .x=x1_, .y=y1_, .t=t1_, id = id,
crs = CRS("+init=epsg:4326"))
mcps <-home_range_trk %>% nest(-id) %>%
mutate(mcparea = map(data, ~hr_mcp(., levels = c(0.95)) %>% hr_area)) %>%
select(id, mcparea) %>% unnest()
#+fig.height=12, fig.width=12, warning=FALSE, message=FALSE
ggplot(mcps, aes(x = id, y = area)) + geom_point()+
geom_smooth()
#' Same for KDE
kde <-home_range_trk %>% nest(-id) %>%
mutate(kdearea = map(data, ~hr_kde(., levels=c(0.95)) %>% hr_area)) %>%
select(id, kdearea) %>% unnest()
#+fig.height=12, fig.width=12, warning=FALSE, message=FALSE
ggplot(kde, aes(x = id, y = kdearea)) + geom_point()+
geom_smooth()
#' map the data
library(leaflet)
#' map the data
library(leaflet)
levels(as.factor(home_range_data$id))
leaflet() %>% addTiles() %>%
addCircleMarkers(data = filter(home_range_data, id == "ID1"),
lat = ~y1_, lng = ~x1_,
color = "blue")
leaflet() %>% addTiles() %>%
addCircleMarkers(data = filter(home_range_data, id == "ID2"),
lat = ~y1_, lng = ~x1_,
color = "blue")
kde
?ID1
?hr_kde
?hr_kde
#' find the centroid
library(geosphere)
home_range_data
home_range_data %>% select(x1_,y1_,id) %>% filter(id=="ID1") %>%  centroid(.)
home_range_data %>% filter(id=="ID1") select(x1_,y1_)  %>%  centroid(.)
home_range_data %>% filter(id=="ID1") %>% select(x1_,y1_)  %>%  centroid(.)
home_range_data %>% filter(id=="ID1") %>% select(x1_,y1_)
ID1 <- home_range_data %>% filter(id=="ID1") %>% select(x1_,y1_)
ID1 <- home_range_data %>% filter(id=="ID1") %>% select(x1_,y1_) %>% rbind(x1_,y1_) %>%  centroid(.)
home_range_data %>% filter(id=="ID1") %>% select(x1_,y1_) %>% rbind(.) %>%  centroid(.)
rbind(home_range_data$x1_, home_range_data$y1_)
home_range_data %>% filter(id=="ID1") %>% select(x1_) %>% mean_x = mean(x1_)
home_range_data %>% filter(id=="ID1") %>%  mean_x = mean(x1_)
mean(home_range_data$x1_)
mean(home_range_data$x1_[home_range_data$id=="ID1"])
mean(home_range_data$y1_[home_range_data$id=="ID1"])
mean(home_range_data$x1_[home_range_data$id=="ID2"])
mean(home_range_data$y1_[home_range_data$id=="ID2"])
mean(home_range_data$x1_[home_range_data$id=="ID1"])
mean(home_range_data$y1_[home_range_data$id=="ID1"])
